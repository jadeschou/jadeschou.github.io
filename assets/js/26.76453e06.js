(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{304:function(t,s,a){"use strict";a.r(s);var n=a(13),r=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"function-和-window-onload-和-document-ready-function"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#function-和-window-onload-和-document-ready-function"}},[t._v("#")]),t._v(" $(function(){})和 window.onload 和 $(document).ready(function(){})")]),t._v(" "),s("p",[t._v("window.onload:用于当页面的所有元素，包括外部引用文件，图片等都加载完毕时运行函数内的函数。load 方法只能执行一次，如果在 js 文件里写了多个，只能执行最后一个。")]),t._v(" "),s("p",[t._v("$(document).ready(function(){})和$(function(){})都是用于当页面的标准 DOM 元素被解析成 DOM 树后就执行内部函数。这个函数是可以在 js 文件里多次编写的，对于多人共同编写的 js 就有很大的优势，因为所有行为函数都会执行到。而且$(document).ready()函数在 HMTL 结构加载完后就可以执行，不需要等大型文件加载或者不存在的连接等耗时工作完成才执行，效率高。")]),t._v(" "),s("h2",{attrs:{id:"简述下-this-和定义属性和方法的时候有什么区别-prototype"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#简述下-this-和定义属性和方法的时候有什么区别-prototype"}},[t._v("#")]),t._v(" 简述下 this 和定义属性和方法的时候有什么区别?Prototype？")]),t._v(" "),s("p",[t._v("this 表示当前对象，如果在全局作用范围内使用 this，则指代当前页面对象 window； 如果在函数中使用 this，则 this 指代什么是根据运行时此函数在什么对象上被调用。 我们还可以使用 apply 和 call 两个全局方法来改变函数中 this 的具体指向。")]),t._v(" "),s("p",[t._v("prototype 本质上还是一个 JavaScript 对象。 并且每个函数都有一个默认的 prototype 属性。")]),t._v(" "),s("p",[t._v("在 prototype 上定义的属性方法为所有实例共享，所有实例皆引用到同一个对象，单一实例对原型上的属性进行修改，也会影响到所有其他实例。")]),t._v(" "),s("h2",{attrs:{id:"箭头函数与普通函数的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数与普通函数的区别"}},[t._v("#")]),t._v(" 箭头函数与普通函数的区别?")]),t._v(" "),s("p",[t._v("函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象\n不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误\n不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替\n不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数")]),t._v(" "),s("h2",{attrs:{id:"自执行函数-用于什么场景-好处"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自执行函数-用于什么场景-好处"}},[t._v("#")]),t._v(" 自执行函数?用于什么场景？好处?")]),t._v(" "),s("p",[s("strong",[t._v("自执行函数")])]),t._v(" "),s("ol",[s("li",[t._v("声明一个匿名函数")]),t._v(" "),s("li",[t._v("马上调用这个匿名函数。")])]),t._v(" "),s("p",[s("strong",[t._v("作用")]),t._v(" ：创建一个独立的作用域。")]),t._v(" "),s("p",[s("strong",[t._v("好处")]),t._v("：防止变量弥散到全局，以免各种 js 库冲突。隔离作用域避免污染，或者截断作用域链，避免闭包造成引用变量无法释放。利用立即执行特性，返回需要的业务函数或对象，避免每次通过条件判断来处理")]),t._v(" "),s("p",[s("strong",[t._v("场景")]),t._v("：一般用于框架、插件等场景")]),t._v(" "),s("h2",{attrs:{id:"回调函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回调函数"}},[t._v("#")]),t._v(" 回调函数?")]),t._v(" "),s("p",[t._v("回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。")]),t._v(" "),s("h2",{attrs:{id:"什么是构造函数-与普通函数有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是构造函数-与普通函数有什么区别"}},[t._v("#")]),t._v(" 什么是构造函数？与普通函数有什么区别?")]),t._v(" "),s("p",[t._v("构造函数：是一种特殊的方法、主要用来创建对象时初始化对象，总与 new 运算符一起使用，创建对象的语句中构造函数的函数名必须与类名完全相同。\n与普通函数相比只能由 new 关键字调用，构造函数是类的标示")]),t._v(" "),s("h2",{attrs:{id:"通过-new-创建一个对象的时候-函数内部有哪些改变"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#通过-new-创建一个对象的时候-函数内部有哪些改变"}},[t._v("#")]),t._v(" 通过 new 创建一个对象的时候，函数内部有哪些改变")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Person")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("friend "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Person")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\na"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("friend"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"王琦"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\na"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"程娇"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。\n2、属性和方法被加入到 this 引用的对象中。\n3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。")])])}),[],!1,null,null,null);s.default=r.exports}}]);