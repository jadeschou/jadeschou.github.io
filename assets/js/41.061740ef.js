(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{323:function(t,e,a){"use strict";a.r(e);var s=a(13),r=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"mvc-和-mvvm-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvc-和-mvvm-区别"}},[t._v("#")]),t._v(" MVC 和 MVVM 区别")]),t._v(" "),e("h3",{attrs:{id:"mvc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[t._v("#")]),t._v(" MVC")]),t._v(" "),e("p",[e("strong",[t._v("MVC")]),t._v(" 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范\n"),e("strong",[t._v("Model")]),t._v("（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据\n"),e("strong",[t._v("View")]),t._v("（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的\n"),e("strong",[t._v("Controller")]),t._v("（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据")]),t._v(" "),e("h3",{attrs:{id:"mvvm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[t._v("#")]),t._v(" MVVM")]),t._v(" "),e("p",[e("strong",[t._v("MVVM")]),t._v(" 是 Model-View-ViewModel 的缩写。\n"),e("strong",[t._v("Model")]),t._v("：代表数据模型，数据和业务逻辑都在 Model 层中定义；\n"),e("strong",[t._v("View")]),t._v("：代表 UI 视图，负责数据的展示；\n"),e("strong",[t._v("ViewModel")]),t._v("：负责监听 Model 中数据的改变并且控制视图的更新，处理用户交互操作；\nModel 和 View 并无直接关联，而是通过 ViewModel 来进行联系的，Model 和 ViewModel 之间有着双向数据绑定的联系，因此当 Model 中的数据改变时会触发 View 层的刷新，View 中由于用户交互操作而改变的数据也会在 Model 中同步。\n这种模式实现了 Model 和 View 的数据自动同步，因此开发者只需要专注对数据的维护操作即可，而不需要手动操作 DOM,")]),t._v(" "),e("h3",{attrs:{id:"mvvm-和-mvc-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mvvm-和-mvc-区别"}},[t._v("#")]),t._v(" "),e("strong",[t._v("mvvm")]),t._v(" 和 "),e("strong",[t._v("mvc")]),t._v(" 区别？")]),t._v(" "),e("ol",[e("li",[t._v("mvc 和 mvvm 都是一种设计思想。 主要就是 mvc 中 Controller 演变成 mvvm 中的 viewModel。 mvvm 主要解决了 mvc 中大量 DOM 操作使页面渲染性能降低，加载速度变慢的问题")]),t._v(" "),e("li",[t._v("MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步：当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素来改变 View 的显示，它会自动变化")]),t._v(" "),e("li",[t._v("整体看来，MVVM 比 MVC 精简很多，我们不用再用选择器频繁地操作 DOM")]),t._v(" "),e("li",[t._v("MVVM 并不是用 VM 完全取代了 C，ViewModel 存在目的在于抽离 Controller 中展示的业务逻辑，而不是替代 Controller，其它视图操作业务等还是应该放在 Controller 中实现。")])]),t._v(" "),e("h2",{attrs:{id:"简述-vue-的响应式原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#简述-vue-的响应式原理"}},[t._v("#")]),t._v(" 简述 Vue 的响应式原理")]),t._v(" "),e("p",[t._v("当一个 Vue 实例创建时，vue 会遍历 data 选项的属性，用 "),e("strong",[t._v("Object.defineProperty")]),t._v(" 将它们转为 "),e("strong",[t._v("getter/setter")]),t._v("并且在内部追踪相关依赖，在属性被访问和修改时通知变化。\n每个组件实例都有相应的 "),e("strong",[t._v("watcher")]),t._v(" 程序实例，它会在组件渲染的过程中把"),e("strong",[t._v("属性")]),t._v("记录为"),e("strong",[t._v("依赖")]),t._v(".\n"),e("strong",[t._v("getter")]),t._v(" 的时候我们会"),e("strong",[t._v("收集依赖")]),t._v("，依赖收集就是订阅数据变化 watcher 的收集，依赖收集的目的是当响应式数据发生变化时，能够通知相应的订阅者去处理相关的逻辑。\n"),e("strong",[t._v("setter")]),t._v(" 的时候会"),e("strong",[t._v("触发依赖更新")]),t._v("，之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。")]),t._v(" "),e("h2",{attrs:{id:"vue-中是如何检测数组变化的呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-中是如何检测数组变化的呢"}},[t._v("#")]),t._v(" vue 中是如何检测数组变化的呢？")]),t._v(" "),e("p",[t._v("数组没有使用 Object.defineProperty() 定义数组每项的 setter 和 getter 方法。\n使用了"),e("strong",[t._v("函数劫持")]),t._v("的方式，重写了数组的方法（push、pop、shift、unshift、splice、sort、reverse）。\nVue 将 data 中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组 api 时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。")]),t._v(" "),e("p",[t._v("vue3：Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。\nProxy 只会代理对象的第一层，那么 Vue3 又是怎样处理这个问题的呢？\n判断当前 Reflect.get 的返回值是否为 Object，如果是则再通过 reactive 方法做代理， 这样就实现了深度观测。\n❝ 监测数组的时候可能触发多次 get/set，那么如何防止触发多次呢？\n我们可以判断 key 是否为当前被代理对象 target 自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行 trigger。")]),t._v(" "),e("h2",{attrs:{id:"vue3-0-用过吗-了解多少"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0-用过吗-了解多少"}},[t._v("#")]),t._v(" vue3.0 用过吗?了解多少")]),t._v(" "),e("p",[t._v("• 响应式原理的改变 Vue3.x 使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty\n• 组件选项声明方式 Vue3.x 使用 Composition API setup 是 Vue3.x 新增的一个选项， 他是组件内使用 Composition API 的入口。\n• 模板语法变化 slot 具名插槽语法 自定义指令 v-model 升级\n• 其它方面的更改 Suspense 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。")]),t._v(" "),e("h2",{attrs:{id:"vue3-0-和-2-0-的响应式原理区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0-和-2-0-的响应式原理区别"}},[t._v("#")]),t._v(" Vue3.0 和 2.0 的响应式原理区别")]),t._v(" "),e("p",[t._v("Vue3.x 改用 "),e("strong",[t._v("Proxy")]),t._v(" 替代 "),e("strong",[t._v("Object.defineProperty")]),t._v("。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。\n"),e("strong",[t._v("Object.defineProperty")]),t._v(" 只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历。Vue 2.x 里,是通过 递归 + 遍历 data 对象来实现对数据的监控的,如果属性值也是对象那么需要深度遍历,显然如果能劫持一个完整的对象是才是更好的选择。\nProxy 可以劫持整个对象,并返回一个新的对象。Proxy 不仅可以代理对象,还可以代理数组。还可以代理动态增加的属性。")]),t._v(" "),e("h2",{attrs:{id:"vue2-x-和-vue3-x-渲染器的-diff-算法分别说一下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue2-x-和-vue3-x-渲染器的-diff-算法分别说一下"}},[t._v("#")]),t._v(" Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下")]),t._v(" "),e("p",[t._v("简单来说，diff 算法有以下过程\n• 同级比较，再比较子节点\n• 先判断一方有子节点一方没有子节点的情况(如果新的 children 没有子节点，将旧的子节点移除)\n• 比较都有子节点的情况(核心 diff)\n• 递归比较子节点\n正常 Diff 两个树的时间复杂度是 O(n^3)，但实际情况下我们很少会进行跨层级的移动 DOM，所以 Vue 将 Diff 进行了优化，从 O(n^3) -> O(n)，只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。\nVue2 的核心 Diff 算法采用了双端比较的算法，同时从新旧 children 的两端开始进行比较，借助 key 值找到可复用的节点，再进行相关操作。相比 React 的 Diff 算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。\nVue3.x 借鉴了\nivi 算法和 inferno 算法\n在创建 VNode 时就确定其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，使得性能上较 Vue2.x 有了提升。(实际的实现可以结合 Vue3.x 源码看。)\n该算法中还运用了动态规划的思想求解最长递归子序列。\n(看到这你还会发现，框架内无处不蕴藏着数据结构和算法的魅力)\n面试官：(可以可以，看来是个苗子，不过自我介绍属实有些无聊，下一题)\n(基操，勿 6)")]),t._v(" "),e("h2",{attrs:{id:"为什么-vue-采用异步渲染呢"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么-vue-采用异步渲染呢"}},[t._v("#")]),t._v(" 为什么 Vue 采用异步渲染呢？")]),t._v(" "),e("p",[t._v("原因：Vue 是组件级更新，如果不采用异步更新，每次更新数据都会对当前组件进行重新渲染.所以为了性能考虑， Vue 会在本轮数据更新后，再去异步更新视图!")]),t._v(" "),e("h2",{attrs:{id:"nexttick-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-是什么"}},[t._v("#")]),t._v(" $nextTick 是什么？")]),t._v(" "),e("p",[t._v("在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。")]),t._v(" "),e("h3",{attrs:{id:"nexttick-实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-实现原理"}},[t._v("#")]),t._v(" nextTick 实现原理?")]),t._v(" "),e("p",[t._v("采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法\n延迟调用优先级如下：\nPromise > MutationObserver > setImmediate > setTimeout")]),t._v(" "),e("h3",{attrs:{id:"nexttick-的主要应用的场景及原因。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-的主要应用的场景及原因。"}},[t._v("#")]),t._v(" nextTick 的主要应用的场景及原因。")]),t._v(" "),e("ol",[e("li",[t._v("在 Vue 生命周期的 created()钩子函数进行的 DOM 操作一定要放在 Vue.nextTick()的回调函数中")]),t._v(" "),e("li",[t._v("在 created()钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，所以此处一定要将 DOM 操作的 js 代码放进 Vue.nextTick()的回调函数中。与之对应的就是 mounted()钩子函数，因为该钩子函数执行时所有的 DOM 挂载和渲染都已完成，此时在该钩子函数中进行任何 DOM 操作都不会有问题 。")]),t._v(" "),e("li",[t._v("在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的 DOM 结构的时候，这个操作都应该放进 Vue.nextTick()的回调函数中。比如我们需要获取数据更新后的 dom 信息，比如动态获取宽高、位置信息等，需要使用 nextTick。")])]),t._v(" "),e("h2",{attrs:{id:"为什么-vue-组件中-data-必须是一个函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么-vue-组件中-data-必须是一个函数"}},[t._v("#")]),t._v(" 为什么 vue 组件中 data 必须是一个函数？")]),t._v(" "),e("p",[t._v("vue 组件中 data 值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。\n如果 data 值为对象，将导致多个实例共享一个对象，其中一个组件改变 data 属性值，其它实例也会受到影响。而使用返回对象的函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的 data，相当于每个组件实例都有自己私有的数据空间，他们只负责各自维护数据，不会造成混乱。")]),t._v(" "),e("h2",{attrs:{id:"vue-组件的优缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件的优缺点"}},[t._v("#")]),t._v(" vue 组件的优缺点")]),t._v(" "),e("p",[t._v("vue 两大特点：响应式编程、组件化。")]),t._v(" "),e("p",[e("strong",[t._v("优点")])]),t._v(" "),e("p",[t._v("轻量级框架、简单易学、双向数据绑定、组件化、数据和结构的分离、虚拟 DOM、运行速度快。\nvue 是单页面应用，使页面局部刷新，这样大大加快了访问速度和提升用户体验。")]),t._v(" "),e("p",[e("strong",[t._v("缺点")])]),t._v(" "),e("p",[t._v("不支持低版本的浏览器，最低只支持到 IE9；\n不利于 SEO 的优化（如果要支持 SEO，建议通过服务端来进行渲染组件）；\n初次加载时耗时多；页面复杂度提高很多。")]),t._v(" "),e("h2",{attrs:{id:"vue-是渐进式的框架的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-是渐进式的框架的理解"}},[t._v("#")]),t._v(" vue 是渐进式的框架的理解")]),t._v(" "),e("p",[t._v("你可以在核心功能的基础上任意选用其他的部件，不一定要全部整合在一起。在核心库的基础上，vue 现在已经有了一套完整的生态系统，我们可以添加 Vuex，可以添加 vue-router,可以添加任何你想添加的第三方库，这些都是互相独立的。")]),t._v(" "),e("h2",{attrs:{id:"前端从输入-url-到页面显示-这个过程发生了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端从输入-url-到页面显示-这个过程发生了什么"}},[t._v("#")]),t._v(" 前端从输入 url 到页面显示，这个过程发生了什么")]),t._v(" "),e("ol",[e("li",[t._v("输入网址；")]),t._v(" "),e("li",[t._v("发送到 DNS 服务器，并获取域名对应的 web 服务器对应的 ip 地址；")]),t._v(" "),e("li",[t._v("与 web 服务器建立 TCP 连接；")]),t._v(" "),e("li",[t._v("浏览器向 web 服务器发送 http 请求；")]),t._v(" "),e("li",[t._v("web 服务器响应请求，并返回指定 url 的数据（或错误信息，或重定向的新的 url 地址）；")]),t._v(" "),e("li",[t._v("浏览器下载 web 服务器返回的数据及解析 html 源文件；")]),t._v(" "),e("li",[t._v("生成 DOM 树，解析 css 和 js，渲染页面，直至显示完成；")])]),t._v(" "),e("h2",{attrs:{id:"开发中常用的指令有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#开发中常用的指令有哪些"}},[t._v("#")]),t._v(" 开发中常用的指令有哪些?")]),t._v(" "),e("ol",[e("li",[t._v("v-model:一般用在表达输入，很轻松的实现表单控件和数据的双向绑定")]),t._v(" "),e("li",[t._v("v-html：更新元素的 innerHTML")]),t._v(" "),e("li",[t._v("v-show 与 v-if：条件渲染，注意二者区别")]),t._v(" "),e("li",[t._v("v-on:click:可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数")]),t._v(" "),e("li",[t._v("v-for：基于源数据多次渲染元素或模板")]),t._v(" "),e("li",[t._v("v-bind:当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM 语法")])]),t._v(" "),e("h2",{attrs:{id:"什么是-vue-的生命周期-生命周期的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-vue-的生命周期-生命周期的作用"}},[t._v("#")]),t._v(" 什么是 vue 的生命周期？生命周期的作用？")]),t._v(" "),e("p",[t._v("Vue 实例从创建到销毁的过程，就是生命周期。\nvue 的生命周期可以简单分为 8 个阶段：创建前/后,载入前/后，更新前/后，销毁前/销毁后\n每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。在这个过程中会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("生命周期钩子")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("组件状态")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("最佳实践")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("beforeCreate")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("在实例初始化之后,此时 data、methods、computed 以及 watch 上的数据和方法还未初始化，都不能被访问")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("常用于初始化非响应式变量：可以在这加个 loading 事件，在加载实例时触发")])]),t._v(" "),e("tr",[e("td",[t._v("created")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("在实例创建完成后被调用。在这一步，实例已完成以下的配置：数据观测 (data observer)属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("常用于简单的 ajax 请求，页面的初始化")])]),t._v(" "),e("tr",[e("td",[t._v("beforeMount")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("在挂载开始之前被调用,相关的 render 函数首次被调用")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("最佳实践")])]),t._v(" "),e("tr",[e("td",[t._v("mounted")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("操作 DOM")])]),t._v(" "),e("tr",[e("td",[t._v("beforeupdate")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器")])]),t._v(" "),e("tr",[e("td",[t._v("updated")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("用于对数据更新做统一处理。避免在这个钩子函数中操作数据，可能陷入死循环")])]),t._v(" "),e("tr",[e("td",[t._v("beforeDestroy")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("清除计时器。 可能在当前页面中使用了 $on 方法，那需要在组件销毁前解绑")])]),t._v(" "),e("tr",[e("td",[t._v("destroyed")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("-")])])])]),t._v(" "),e("h2",{attrs:{id:"第一次页面加载会触发那几个钩子"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第一次页面加载会触发那几个钩子"}},[t._v("#")]),t._v(" 第一次页面加载会触发那几个钩子？")]),t._v(" "),e("p",[t._v("第一次页面加载时会触发 beforeCreate,created,beforeMount,mounted")]),t._v(" "),e("h2",{attrs:{id:"created-和-mounted-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#created-和-mounted-的区别"}},[t._v("#")]),t._v(" created 和 mounted 的区别")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("created")]),t._v(":在模板渲染成 html 前调用，即通常初始化某些属性值，然后再渲染成视图。")]),t._v(" "),e("li",[e("strong",[t._v("mounted")]),t._v(":在模板渲染成 html 后调用，通常是初始化页面完成后，再对 html 的 dom 节点进行一些需要的操作。")])]),t._v(" "),e("h2",{attrs:{id:"异步请求在哪一步发起"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步请求在哪一步发起"}},[t._v("#")]),t._v(" 异步请求在哪一步发起？")]),t._v(" "),e("p",[t._v("可以在钩子函数 "),e("strong",[t._v("created、beforeMount、mounted")]),t._v("中进行异步请求，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。\n如果异步请求不需要依赖 DOM 推荐在 "),e("strong",[t._v("created")]),t._v(" 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：")]),t._v(" "),e("ul",[e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("能更快获取到服务端数据，减少页面 loading 时间；\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；\n")])])])])]),t._v(" "),e("h2",{attrs:{id:"接口放在哪个生命周期中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#接口放在哪个生命周期中"}},[t._v("#")]),t._v(" 接口放在哪个生命周期中")]),t._v(" "),e("p",[t._v("在 "),e("strong",[t._v("created")]),t._v(" 的时候，视图中的 dom 并没有渲染出来，所以此时如果直接去操 dom 节点，无法找到相关的元素\n在 "),e("strong",[t._v("mounted")]),t._v(" 中，由于此时 dom 已经渲染出来了，所以可以直接操作 dom 节点\n一般情况下都放到 mounted 中,保证逻辑的统一性,因为生命周期是同步执行的， ajax 是异步执行的\n但需要注意的是服务端渲染时不支持 mounted，需要放到 created 中。")]),t._v(" "),e("h2",{attrs:{id:"父子组件生命周期调用顺序-简单"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#父子组件生命周期调用顺序-简单"}},[t._v("#")]),t._v(" 父子组件生命周期调用顺序（简单）")]),t._v(" "),e("p",[e("strong",[t._v("渲染顺序")]),t._v("：先父后子，完成顺序：先子后父\n"),e("strong",[t._v("更新顺序")]),t._v("：父更新导致子更新，子更新完成后父\n"),e("strong",[t._v("销毁顺序")]),t._v("：先父后子，完成顺序：先子后父")]),t._v(" "),e("p",[e("strong",[t._v("加载渲染过程")]),t._v("\n父 beforeCreate->父 created->父 beforeMount->子 beforeCreate->子 created->子 beforeMount->子 mounted->父 mounted\n"),e("strong",[t._v("子组件更新过程")]),t._v("\n父 beforeUpdate->子 beforeUpdate->子 updated->父 updated\n"),e("strong",[t._v("父组件更新过程")]),t._v("\n父 beforeUpdate->父 updated\n"),e("strong",[t._v("销毁过程")]),t._v("\n父 beforeDestroy->子 beforeDestroy->子 destroyed->父 destroyed")]),t._v(" "),e("h2",{attrs:{id:"vue-和-jquery-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-和-jquery-的区别"}},[t._v("#")]),t._v(" vue 和 jQuery 的区别")]),t._v(" "),e("ul",[e("li",[e("p",[e("strong",[t._v("jQuery")]),t._v(' 是使用选择器选取 DOM 对象，对其进行赋值、取值、事件绑定等操作，其实和原生的 HTML 的区别只在于可以更方便的选取和操作 DOM 对象，而数据和界面是在一起的。比如需要获取 label 标签的内容：$("lable").val(); ,它还是依赖 DOM 元素的值。')])]),t._v(" "),e("li",[e("p",[e("strong",[t._v("Vue")]),t._v(" 则是通过 Vue 对象将数据和 View 完全分离开来了。对数据进行操作不再需要引用相应的 DOM 对象，可以说数据和 View 是分离的，他们通过 Vue 对象这个 vm 实现相互的绑定。这就是传说中的 MVVM。当然 vue 可能通过 ref 来选择一个 dom 或组件")])])]),t._v(" "),e("h2",{attrs:{id:"v-if-和-v-show-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show-的区别"}},[t._v("#")]),t._v(" v-if 和 v-show 的区别")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",{staticStyle:{"text-align":"left"}},[t._v("概述")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("性能消耗")]),t._v(" "),e("th",{staticStyle:{"text-align":"left"}},[t._v("使用场景")])])]),t._v(" "),e("tbody",[e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("v-show 指令是通过修改元素的 display 的 CSS 属性让其显示或者隐藏")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("有更高的初始渲染消耗")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("适用于需要非常频繁切换条件的场景")])]),t._v(" "),e("tr",[e("td",{staticStyle:{"text-align":"left"}},[t._v("v-if 指令是直接销毁和重建 DOM 达到让元素显示和隐藏的效果")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("有更高的切换消耗")]),t._v(" "),e("td",{staticStyle:{"text-align":"left"}},[t._v("适用于在运行时很少改变条件，不需要频繁切换条件的场景 对于管理系统权限列表的展示，用 v-if")])])])]),t._v(" "),e("h2",{attrs:{id:"v-for-和-v-if-优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-for-和-v-if-优先级"}},[t._v("#")]),t._v(" v-for 和 v-if 优先级")]),t._v(" "),e("p",[e("strong",[t._v("v-for")]),t._v("的优先级是高于"),e("strong",[t._v("v-if")]),t._v("的，如果两者同时出现的话，那每次循环都会执行 v-if，会很浪费性能，我们正确的做法应该是再 v-for 的外面新增一个模板标签 template，在 template 上使用 v-if\n我们经常会遇见这种情况，在 v-for 的时候，在数组中会有一些需要进行 v-if 的判断，这种情况下，我们如果先使用 computed 将不需要渲染的项过滤出来，那么在进行 v-for 的时候，循环的就只是需要渲染的项，这也是提升 vue 性能的一种方式。")]),t._v(" "),e("h2",{attrs:{id:"v-for-为什么要加-key"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-for-为什么要加-key"}},[t._v("#")]),t._v(" v-for 为什么要加 key")]),t._v(" "),e("p",[e("strong",[t._v("key")]),t._v(" 是给每一个 "),e("strong",[t._v("vnode")]),t._v(" 的唯一 id,依靠 key,我们的 diff 操作可以更准确、更快速 (对于简单列表页渲染来说 diff 节点也更快,但会产生一些隐藏的副作用,比如可能不会产生过渡效果,或者在某些节点有绑定数据（表单）状态，会出现状态错位。)\ndiff 算法的过程中,先会进行新旧节点的首尾交叉对比,当无法匹配的时候会用新节点的 key 与旧节点进行比对,从而找到相应旧节点.\n更准确 : 因为带 key 就不是就地复用了,在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确,如果不加 key,会导致之前节点的状态被保留下来,会产生一系列的 bug。\n更快速 : key 的唯一性可以被 Map 数据结构充分利用,相比于遍历查找的时间复杂度 O(n),Map 的时间复杂度仅仅为 O(1)")]),t._v(" "),e("h2",{attrs:{id:"v-on-可以监听多个方法吗-可以的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-on-可以监听多个方法吗-可以的"}},[t._v("#")]),t._v(" v-on 可以监听多个方法吗？（可以的）")]),t._v(" "),e("p",[t._v("监听多个方法，绑定多函数")]),t._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("p")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("v-on")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{click:dbclick,mousemove:mouseClick}"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("a")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("@click")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("one(),two()"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("a")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("p")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),e("h2",{attrs:{id:"vue-组件如何通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件如何通信"}},[t._v("#")]),t._v(" Vue 组件如何通信？")]),t._v(" "),e("ol",[e("li",[t._v("props / $emit 适用 父子组件通信")]),t._v(" "),e("li",[t._v("ref 与 $parent / $children 适用 父子组件通信")]),t._v(" "),e("li",[t._v("EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信\n这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。")]),t._v(" "),e("li",[t._v('$attrs/$listeners 适用于 隔代组件通信\n• $attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind="$attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。\n• $listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on="$listeners" 传入内部组件')]),t._v(" "),e("li",[t._v("provide / inject 适用于 隔代组件通信\n祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。")]),t._v(" "),e("li",[t._v("vuex 适用于 父子、隔代、兄弟组件通信\nVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。")])]),t._v(" "),e("h2",{attrs:{id:"vue-中的-ref-是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-中的-ref-是什么"}},[t._v("#")]),t._v(" vue 中的 ref 是什么？")]),t._v(" "),e("p",[t._v("ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向该子组件实例 ref 用来辅助我们获取 DOM 元素或组件的引用实例对象,")]),t._v(" "),e("h2",{attrs:{id:"如何获取-dom"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何获取-dom"}},[t._v("#")]),t._v(" 如何获取 dom")]),t._v(" "),e("p",[t._v("给 dom 元素加 "),e("code",[t._v("ref='refname'")]),t._v(",然后通过 "),e("code",[t._v("this.$refs.refname")]),t._v(" 进行获取 dom 元素")]),t._v(" "),e("h2",{attrs:{id:"vue-loader-是什么-使用它的用途有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-loader-是什么-使用它的用途有哪些"}},[t._v("#")]),t._v(" vue-loader 是什么？使用它的用途有哪些？")]),t._v(" "),e("p",[e("strong",[t._v("vue-loader")]),t._v("是 vue 文件的一个加载器，解析和转换.vue 文件。提取出其中的逻辑代码 script,样式代码 style,以及 HTML 模板 template，再分别把他们交给对应的 loader 去处理\n用途：js 可以写 es6、style 样式可以 scss 或 less；template 可以加 jade 等；")]),t._v(" "),e("h2",{attrs:{id:"谈一下对-vuex-的个人理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#谈一下对-vuex-的个人理解"}},[t._v("#")]),t._v(" 谈一下对 vuex 的个人理解")]),t._v(" "),e("p",[t._v("Vuex 是 vue 的状态管理工具。它采用集中式存储管理应用的所有组件的状态，实现多组件间的状态共享。\n核心属性是 state、getter、mutation、action、module")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("state")]),t._v(" => 基本数据(数据源存放地)")]),t._v(" "),e("li",[e("strong",[t._v("getters")]),t._v(" => 从基本数据派⽣出来的数据 （相当于计算属性 例如对列表进行过滤并计数）")]),t._v(" "),e("li",[e("strong",[t._v("mutations")]),t._v(" => 提交更改数据的方法，同步")]),t._v(" "),e("li",[e("strong",[t._v("actions")]),t._v(" => 像一个装饰器，包裹 mutations，使之可以异步")]),t._v(" "),e("li",[e("strong",[t._v("modules")]),t._v(" => 模块化 Vuex")])]),t._v(" "),e("p",[e("strong",[t._v("vuex 和普通全局对象区别")]),t._v("\n1、Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。\n2、你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。\nVuex 使用场景：购物车、用户登录")]),t._v(" "),e("h2",{attrs:{id:"vuex-页面刷新数据丢失怎么解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex-页面刷新数据丢失怎么解决"}},[t._v("#")]),t._v(" Vuex 页面刷新数据丢失怎么解决")]),t._v(" "),e("p",[t._v("需要做 vuex 数据持久化 一般使用本地存储的方案来保存数据\n//在页面加载时读取 sessionStorage 里的状态信息\n//在页面刷新时将 vuex 里的信息保存到 sessionStorage 里\n其实这里还可以用 localStorage，但是它没有期限；所以常用的还是 sessionStorage，当浏览器关闭时会话结束。\n也可以使用第三方插件。推荐使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中")]),t._v(" "),e("h2",{attrs:{id:"vuex-为什么要分模块并且加命名空间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex-为什么要分模块并且加命名空间"}},[t._v("#")]),t._v(" Vuex 为什么要分模块并且加命名空间")]),t._v(" "),e("p",[e("strong",[t._v("模块")]),t._v(":由于使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。\n为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。\n"),e("strong",[t._v("命名空间")]),t._v("：为了解决不同模块命名冲突的问题，将不同模块的 namespaced:true，之后在不同页面中引入 getter、actions、mutations 时，需要加上所属的模块名")]),t._v(" "),e("h2",{attrs:{id:"vuex-如何获取和修改数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vuex-如何获取和修改数据"}},[t._v("#")]),t._v(" Vuex 如何获取和修改数据")]),t._v(" "),e("p",[e("strong",[t._v("获取数据")])]),t._v(" "),e("ol",[e("li",[t._v("$store.state 是可以获取 vuex 仓库的数据,也可以用计算属性 computed 返回某个状态;")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("count () {\nreturn store.state.count\n}\n")])])]),e("ol",[e("li",[t._v("使用 mapState 辅助函数帮助我们生成计算属性")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("computed: mapState({\n// 箭头函数可使代码更简练\ncount: state => state.count,\n})\ncomputed:{\n...mapState({\nisLogin:state=>state.isLogin\n}),\n//等同于==>...mapState(['isLogin']);映射 this.isLogin 为 this.$store.state.isLogin\n}\n")])])]),e("p",[e("strong",[t._v("更改数据")]),t._v("\nvuex 修改数据在 "),e("strong",[t._v("mutations")]),t._v(" 里面修改{所有组件(顶级组件和子组件)都可以在这里修改数据}\n在组件 "),e("strong",[t._v("methods")]),t._v(" 中定义方法即可, 用 "),e("code",[t._v("this.$store.commit('方法名',参数)")]),t._v("行内绑定事件\n把方法定义到 "),e("strong",[t._v("main.js")]),t._v(" 中 "),e("strong",[t._v("mutations")]),t._v(" 中即可")]),t._v(" "),e("h2",{attrs:{id:"action-与-mutation-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#action-与-mutation-的区别"}},[t._v("#")]),t._v(" action 与 mutation 的区别")]),t._v(" "),e("p",[e("strong",[t._v("mutation")]),t._v(" 是同步更新，$watch 严格模式下会报错\n"),e("strong",[t._v("action")]),t._v(" 是异步操作，可以获取数据后调用 mutation 提交最终数据")]),t._v(" "),e("h2",{attrs:{id:"keep-alive-的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-的理解"}},[t._v("#")]),t._v(" keep-alive 的理解")]),t._v(" "),e("p",[e("strong",[t._v("keep-alive")]),t._v(" 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：")]),t._v(" "),e("ul",[e("li",[t._v("一般结合路由和动态组件一起使用，用于缓存组件；")]),t._v(" "),e("li",[t._v("提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；")]),t._v(" "),e("li",[t._v("对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。")])]),t._v(" "),e("h2",{attrs:{id:"vue-extend-作用和原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-extend-作用和原理"}},[t._v("#")]),t._v(" Vue.extend 作用和原理")]),t._v(" "),e("p",[t._v("官方解释：Vue.extend 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。\n其实就是一个子类构造器 是 Vue 组件的核心 api 实现思路就是使用原型继承的方法返回了 Vue 的子类 并且利用 mergeOptions 把传入组件的 options 和父类的 options 进行了合并")]),t._v(" "),e("h2",{attrs:{id:"computed-和-watch-的区别和运用的场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-的区别和运用的场景"}},[t._v("#")]),t._v(" computed 和 watch 的区别和运用的场景？")]),t._v(" "),e("p",[t._v("computed： computed 是计算属性，依赖其它属性值,并且 computed 的值有缓存,只有它依赖的 属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。")]),t._v(" "),e("p",[t._v("watch：更多的是观察的作用,无缓存性,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。\n当我们需要深度监听对象中的属性时，可以打开 deep：true 选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用 unWatch 手动注销哦。\n运用场景：")]),t._v(" "),e("ul",[e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("当我们需要进行数值计算,并且依赖于其它数据时,应该使用 computed,因为可以利用 computed的缓存特性,避免每次获取值时,都要重新计算。\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("当我们需要在数据变化时执行异步或开销较大的操作时,应该使用 watch,使用 watch 选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率, 并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("多个因素影响一个显示，用Computed；一个因素的变化影响多个其他因素、显示，用Watch;\n")])])])])]),t._v(" "),e("h2",{attrs:{id:"computed-和-methods-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-methods-的区别"}},[t._v("#")]),t._v(" Computed 和 Methods 的区别")]),t._v(" "),e("p",[t._v("区别一个是主动与被动，简单点讲就是 methods 是需要去人为触发的，而 computed 是在检测到 data 数据变化时自动触发的\n另一个是 methods 的运算是没有缓存的，computed 运算是有缓存的（只要运算所依赖的数据没有发生变化就会从缓存中取出结果）")]),t._v(" "),e("h2",{attrs:{id:"computed-的实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#computed-的实现原理"}},[t._v("#")]),t._v(" computed 的实现原理")]),t._v(" "),e("p",[t._v("computed 本质是一个惰性求值的观察者。\ncomputed 内部实现了一个惰性的 watcher,也就是 computed watcher,computed watcher 不会立刻求值,同时持有一个 dep 实例。\n其内部通过 this.dirty 属性标记计算属性是否需要重新求值。\n当 computed 的依赖状态发生改变时,就会通知这个惰性的 watcher,\ncomputed watcher 通过 this.dep.subs.length 判断有没有订阅者,\n有的话,会重新计算,然后对比新旧值,如果变化了,会重新渲染。 (Vue 想确保不仅仅是计算属性依赖的值发生变化，而是当计算属性最终计算的值发生变化时才会触发渲染 watcher 重新渲染，本质上是一种优化。)\n没有的话,仅仅把 this.dirty = true。 (当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备 lazy（懒计算）特性。)")]),t._v(" "),e("h2",{attrs:{id:"虚拟-dom-实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚拟-dom-实现原理"}},[t._v("#")]),t._v(" 虚拟 DOM 实现原理?")]),t._v(" "),e("p",[t._v("虚拟 DOM 本质上是 JavaScript 对象,是对真实 DOM 的抽象\n状态变更时，记录新树和旧树的差异\n最后把差异更新到真正的 dom 中")]),t._v(" "),e("h2",{attrs:{id:"vue-初始化页面闪动问题如何解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-初始化页面闪动问题如何解决"}},[t._v("#")]),t._v(" Vue 初始化页面闪动问题如何解决？")]),t._v(" "),e("p",[t._v("出现该问题是因为在 Vue 代码尚未被解析之前，尚无法控制页面中 DOM 的显示，所以会看见模板字符串等代码。\n解决方案是，在 css 代码中添加 v-cloak 规则，同时在待编译的标签上添加 v-cloak 属性：")]),t._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[t._v("[v-cloak] { display: none; }\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("div")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("v-cloak")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("{{ message }}"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("div")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),e("h2",{attrs:{id:"vue-router-hash-模式-history-模式区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-hash-模式-history-模式区别"}},[t._v("#")]),t._v(" Vue-router hash 模式 history 模式区别？")]),t._v(" "),e("ol",[e("li",[t._v("hash 模式（vue-router 默认 hash 模式）\nhash 模式背后的原理是 onhashchange 事件。")])]),t._v(" "),e("p",[t._v("window.οnhashchange=function(){\nlet hash=location.hash.slice(1);\ndocument.body.style.color=hash;\n}\n（localtion 是 js 里管理地址栏的内置对象，是 window 对象的一部分，可通过 window.localtion 访问，在 w3cshool 里的详细介绍)\n由于 hash 发生变化的 url 都会被浏览器记录下来，使得浏览器的前进后退都可以使用了，尽管浏览器没有亲求服务器，但是页面状态和 url 关联起来。后来人们称其为前端路由，成为单页应用标配。")]),t._v(" "),e("p",[t._v("比如http://www.abc.com/#/index，hash值为#/index。hash模式的特点在于hash出现在url中，但是不会被包括在HTTP请求中，对后端没有影响，不会重新加载页面。")]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("p",[t._v("history 模式\nhistory 模式利用了 HTML5 History Interface 中新增的 pushState()和 replaceState()方法。MDN 相关介绍（需要特定浏览器支持）。这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了 url，但浏览器不会立即向后端发送请求。\n当使用 history 模式时，url 就像正常的 url,例如http://abc.com/user/id相比hash模式更加好看。特别注意，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。\n通过 history api，我们丢弃了丑陋的#，但是有一个缺点，当刷新时，如果服务器中没有相应的相应或者资源，会分分钟刷出一个 404 来（刷新需要请求服务器）。所以 history 模式不怕前进，不怕后退，就怕刷新。")])]),t._v(" "),e("li",[e("p",[t._v("hash 模式和 history 模式对比\npushState()设置新的 url 可以是和当前 url"),e("strong",[t._v("同源的任意 url;hash 只可修改#后面的部分，只能设置当前 url 同文档")]),t._v("的 url。\npushState()设置的新 url 可与当前 url 一致，这样也会把记录添加到栈中；hash 必须设置与当前 url 不同的 url 的，才会触发动作将记录添加到栈中。\npushState()通过 stateObject 参数可以添加任意类型的数据到记录中；hash 只可添加短字符串。\npushState()可额外设置 title 属性供后续使用。\n不过，hash 模式也有比 history 模式优势的地方。hash 模式下，仅 hash 符号之前的 url 会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回 404 错误。\nhistory 模式下，前端的 url 必须和实际向后端发起请求的 url 一致，如http://abc.com/user/id,后端如果没有对user/id的路由处理，将返回404错误。")])])]),t._v(" "),e("h2",{attrs:{id:"路由跳转方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#路由跳转方式"}},[t._v("#")]),t._v(" 路由跳转方式")]),t._v(" "),e("p",[t._v("不带参数：\n注意：router-link 中链接如果是'/'开始就是从根路由开始，如果开始不带'/'，则从当前路由开始。")]),t._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("router-link")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":to")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{name:'home'}"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("router-link")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":to")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{path:'/home'}"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    //name,path都行, 建议用name"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("router-link")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("router-link")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),e("p",[t._v("带参数：")]),t._v(" "),e("div",{staticClass:"language-html extra-class"},[e("pre",{pre:!0,attrs:{class:"language-html"}},[e("code",[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("router-link")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":to")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{name:'home', params: {id:1}}"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("router-link")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":to")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("{name:'home', query: {id:1}}"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("router-link")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v(":to")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("/home/:id"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("router-link")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("router-link")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("router-link")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),e("p",[t._v("传递对象")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<router-link :to=\"{name:'detail', query: {item:JSON.stringify(obj)}}\"></router-link>\n")])])]),e("h2",{attrs:{id:"vue-router-跳转和-location-href-有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-跳转和-location-href-有什么区别"}},[t._v("#")]),t._v(" Vue-router 跳转和 location.href 有什么区别")]),t._v(" "),e("p",[t._v("location.href= /url 来跳转，简单方便，但是刷新了页面；\nhistory.pushState( /url ) ，无刷新页面，静态跳转；\n引进 router ，然后使用 router.push( /url ) 来跳转，使用了 diff 算法，实现了按需加载，减少了 dom 的消耗。\n其实使用 router 跳转和使用 history.pushState() 没什么差别的，因为 vue-router 就是用了 history.pushState() ，尤其是在 history 模式下。")]),t._v(" "),e("h2",{attrs:{id:"active-class-是哪个组件的属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#active-class-是哪个组件的属性"}},[t._v("#")]),t._v(" active-class 是哪个组件的属性？")]),t._v(" "),e("p",[t._v("active-class 是 vue-router 模块的 router-link 组件中的属性，用来做选中样式的切换；\n在 vue-router 中要使用 active-class 有两种方法：")]),t._v(" "),e("ol",[e("li",[t._v("在 router-link 中写入 active-class\nactive-class 选择样式时根据路由中的路径（to=“/home”）去匹配，然后显示")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<router-link to="/home" class="menu-home" active-class="active">首页</router-link>\n')])])]),e("ol",{attrs:{start:"2"}},[e("li",[t._v("直接在路由 js 文件中配置 linkActiveClass")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("export default new Router({\nlinkActiveClass: 'active',\n})\n")])])]),e("h2",{attrs:{id:"vue-router-动态路由是什么-有什么问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-动态路由是什么-有什么问题"}},[t._v("#")]),t._v(" vue-router 动态路由是什么 有什么问题")]),t._v(" "),e("p",[t._v("我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。\n例如，商品详情页，页面结构都一样，只是商品 id 的不同，所以这个时候就可以用动态路由动态。\n一个路由中设置多段“路径参数”，对应的值都会设置到$route.params 中。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("export default new Router({\nroutes: [\n{\npath:'/testRouter3/:id',//通过：参数的格式配置动态路由\nname:'TestRouter3',\n}\n]\n})\n")])])]),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("$route.params.testId:获取当前路由的参数。\n")])])]),e("h2",{attrs:{id:"vue-router-如何响应-路由参数-的变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-如何响应-路由参数-的变化"}},[t._v("#")]),t._v(" vue-router 如何响应 路由参数 的变化？")]),t._v(" "),e("p",[t._v("原来的组件实例会被复用。这也意味着组件的生命周期钩子不会再被调用。你可以简单地 watch (监测变化) $route 对象：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const User = {\ntemplate: '...',\nwatch: {\n'$route' (to, from) {\n// 对路由变化作出响应...\n}\n}\n}\n")])])]),e("h2",{attrs:{id:"routerlink-在-ie-和-firefox-中不起作用-路由不跳转-的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#routerlink-在-ie-和-firefox-中不起作用-路由不跳转-的问题"}},[t._v("#")]),t._v(" RouterLink 在 IE 和 Firefox 中不起作用（路由不跳转）的问题")]),t._v(" "),e("p",[t._v("答: 方法一：只用 a 标签，不适用 button 标签；方法二：使用 button 标签和 Router.navigate 方法")]),t._v(" "),e("h2",{attrs:{id:"vue-里面-router-link-在电脑上有用-在安卓上没反应怎么解决"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-里面-router-link-在电脑上有用-在安卓上没反应怎么解决"}},[t._v("#")]),t._v(" Vue 里面 router-link 在电脑上有用，在安卓上没反应怎么解决？")]),t._v(" "),e("p",[t._v("Vue 路由在 Android 机上有问题，babel 问题，安装 babel polypill 插件解决。")]),t._v(" "),e("h2",{attrs:{id:"vue-路由传参数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-路由传参数"}},[t._v("#")]),t._v(" vue 路由传参数")]),t._v(" "),e("p",[t._v("1.使用 query 方法传入的参数使用 this.$route.query接受\n2.使用params方式传入的参数使用this.$route.params 接受\n用法：query 要用 path 来引入，params 要用 name 来引入，接收参数都是类似的，分别是 this.$route.query.name 和 this.$route.params.name 。url 地址显示：query 更加类似于我们 ajax 中 get 传参，params 则类似于 post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示\n注意点：query 刷新不会丢失 query 里面的数据 params 刷新会丢失 params 里面的数据。")]),t._v(" "),e("h2",{attrs:{id:"完整的导航解析流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#完整的导航解析流程"}},[t._v("#")]),t._v(" 完整的导航解析流程")]),t._v(" "),e("p",[t._v("1.导航被触发； 2.在失活的组件里调用 beforeRouteLeave 守卫； 3.调用全局 beforeEach 守卫； 4.在复用组件里调用 beforeRouteUpdate 守卫； 5.调用路由配置里的 beforeEnter 守卫； 6.解析异步路由组件； 7.在被激活的组件里调用 beforeRouteEnter 守卫； 8.调用全局 beforeResolve 守卫； 9.导航被确认；\n10..调用全局的 afterEach 钩子；\n11.DOM 更新； 12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。")]),t._v(" "),e("h2",{attrs:{id:"导航守卫有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#导航守卫有哪些"}},[t._v("#")]),t._v(" 导航守卫有哪些？")]),t._v(" "),e("p",[t._v("全局守卫：beforeEachafterEach beforeResolve\n路由独享守卫：beforeEnter\n组件内守卫：beforeRouteEnter beforeEnterUpdata beforeRouteLeave")]),t._v(" "),e("h2",{attrs:{id:"插槽与作用域插槽的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#插槽与作用域插槽的区别"}},[t._v("#")]),t._v(" 插槽与作用域插槽的区别")]),t._v(" "),e("p",[t._v("插槽 创建组件虚拟节点时，会将组件儿子的虚拟节点保存起来。当初始化组件时，通过插槽属性将儿子进行分类 {a:[vnode],b[vnode]} 渲染组件时会拿对应的 slot 属性的节点进行替换操作。（插槽的作用域为父组件） 作用域插槽 作用域插槽在解析的时候不会作为组件的孩子节点。会解析成函数，当子组件渲染时，会调用此函数进行渲染。 普通插槽渲染的作用域是父组件，作用域插槽的渲染作用域是当前子组件。")]),t._v(" "),e("h2",{attrs:{id:"axios-的特点有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#axios-的特点有哪些"}},[t._v("#")]),t._v(" axios 的特点有哪些？")]),t._v(" "),e("p",[t._v("1、axios 是一个基于 promise 的 HTTP 库，支持 promise 的所有 API；\n2、它可以拦截请求和响应；\n3、它可以转换请求数据和响应数据，并对响应回来的内容自动转换为 json 类型的数据；\n4、安全性更高，客户端支持防御 XSRF；")]),t._v(" "),e("h2",{attrs:{id:"拦截的使用场景-用户登录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#拦截的使用场景-用户登录"}},[t._v("#")]),t._v(" 拦截的使用场景（用户登录）")]),t._v(" "),e("p",[t._v("请求拦截：")]),t._v(" "),e("ol",[e("li",[t._v("路由拦截：首先在定义路由的时候就需要多添加一个自定义字段 requireAuth， 定义完路由后, 我们主要是利用 vue-router 提供的钩子函数 beforeEach()对路由进行判断.如果用户已经登录, 则顺利进入路由, 否则就进入登录页面. 2.设置请求/响应拦截：在后面的所有请求中都将携带 token 进行。\n利用 axios 中的请求拦截器, 通过配置 http response inteceptor, 当后端接口返回 401 Unauthorized (未授权), 让用户重新执行登录操作。\n3.axios 拦截器对 http 请求的响应状态统一进行处理\n这个项目我引入了 element ui 框架, 所以我是结合 element 中 loading 和 message 组件来处理的.。在封装好的 axios.js 中引入 element ui 中的 loading 和 message 组件，请求时加载 loading，响应后关闭 loading 并返回 message 状态\n响应拦截\n响应的失败拦截中，可以根据 status 判断报错的错误码，跳转到不同的错误提示页面。")])]),t._v(" "),e("h2",{attrs:{id:"axios-引入步骤"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#axios-引入步骤"}},[t._v("#")]),t._v(" Axios 引入步骤")]),t._v(" "),e("p",[t._v("1.npm install --save axios 2.在 main.js 里面引入 import axios from ‘axios’ 3.在 main.js 中加到 vue 的原型上 Vue.prototype.axios =axios; 4. 一般我会在项目的 src 目录中，新建一个 request 文件夹，然后在里面新建一个 http.js 来封装我们的 axios\n项目中通常将业务需求统一存放在一个目录下管理，例如在 src 目录中新建 api 文件夹，这里面放入组件中用到的所有封装好的 http 请求并导出，再其他用到的组件中导入调用。")]),t._v(" "),e("h2",{attrs:{id:"vue-中如何解决跨域问题-proxy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-中如何解决跨域问题-proxy"}},[t._v("#")]),t._v(" VUE 中如何解决跨域问题（proxy）")]),t._v(" "),e("p",[t._v("当我们遇到请求后台接口遇到 Access-Control-Allow-Origin 时，那说明跨域了。\n跨域是因为浏览器的同源策略所导致，同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，同源是指：域名、协议、端口相同.\n1、在 vue.config.js 中设置如下代码片段")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("module.exports = {\n  dev: {\n    // Paths\n    assetsSubDirectory: 'static',\n    assetsPublicPath: '/',\n    proxyTable: { // 配置跨域\n    '/api':{\n        target:`http://www.baidu.com`, //请求后台接口\n        changeOrigin:true, // 允许跨域\n        pathRewrite:{\n            '^/api' : '' // 重写请求\n        }\n    }\n  },\n}\n")])])]),e("p",[t._v("2、创捷 axioss 实例时，将 baseUrl 设置为 ‘/api’")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("const http = axios.create({\n  timeout: 1000 * 1000000,\n  withCredentials: true,\n  BASE_URL: '/api'\n  headers: {\n     'Content-Type': 'application/json; charset=utf-8'\n   }\n})\n")])])]),e("h2",{attrs:{id:"请说出-vue-cli-项目中-src-目录每个文件夹和文件的用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#请说出-vue-cli-项目中-src-目录每个文件夹和文件的用法"}},[t._v("#")]),t._v(" 请说出 vue.cli 项目中 src 目录每个文件夹和文件的用法？")]),t._v(" "),e("p",[t._v("assets 文件夹是放静态资源；\ncomponents 是放组件；\nrouter 是定义路由相关的配置;\nview 视图；\napp.vue 是一个应用主组件；\nmain.js 是入口文件")]),t._v(" "),e("h2",{attrs:{id:"route-和-router-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#route-和-router-的区别"}},[t._v("#")]),t._v(" $route 和 $router 的区别")]),t._v(" "),e("p",[t._v("router ：路由实例，对象包括了路由的跳转方法，钩子函数等\nroute 为路由信息对象。可以获取 path，params，params，name 等路由信息参数。\n。")]),t._v(" "),e("h2",{attrs:{id:"谈谈对-keep-alive-的了解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#谈谈对-keep-alive-的了解"}},[t._v("#")]),t._v(" 谈谈对 keep-alive 的了解")]),t._v(" "),e("p",[t._v("keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。\nkeep-alive 可以实现组件的缓存，当组件切换时不会对当前组件进行卸载。常用的 2 个属性 include/exclude，2 个生命周期 activated， deactivated")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<keep-alive>\n<component>\n\x3c!-- 该组件将被缓存！ --\x3e\n</component>\n</keep-alive>\n")])])]),e("p",[t._v("如果只想 router-view 里面某个组件被缓存")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("export default [\n{\npath: '/',\nname: 'home',\ncomponent: Home,\nmeta: {\nkeepAlive: true // 需要被缓存\n}\n}, {\npath: '/:id',\nname: 'edit',\ncomponent: Edit,\nmeta: {\nkeepAlive: false // 不需要被缓存\n}\n}\n]\n<keep-alive>\n\n<router-view v-if=\"$route.meta.keepAlive\">\n\x3c!-- 这里是会被缓存的视图组件，比如 Home！ --\x3e\n</router-view>\n</keep-alive>\n\n<router-view v-if=\"!$route.meta.keepAlive\">\n\x3c!-- 这里是不被缓存的视图组件，比如 Edit！ --\x3e\n</router-view>\n")])])]),e("h2",{attrs:{id:"vue-模板编译原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-模板编译原理"}},[t._v("#")]),t._v(" Vue 模板编译原理")]),t._v(" "),e("p",[t._v("Vue 的编译过程就是将 template 转化为 render 函数的过程 分为以下三步\n第一步是将 模板字符串 转换成 element ASTs（解析器）\n第二步是对 AST 进行静态节点标记，主要用来做虚拟 DOM 的渲染优化（优化器）\n第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器）")]),t._v(" "),e("h2",{attrs:{id:"你们-vue-项目是打包了一个-js-文件-一个-css-文件-还是有多个文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#你们-vue-项目是打包了一个-js-文件-一个-css-文件-还是有多个文件"}},[t._v("#")]),t._v(" 你们 vue 项目是打包了一个 js 文件，一个 css 文件，还是有多个文件？")]),t._v(" "),e("p",[t._v("答：根据 vue-cli 脚手架规范，一个 js 文件，一个 CSS 文件。")]),t._v(" "),e("h2",{attrs:{id:"封装-vue-组件的过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#封装-vue-组件的过程"}},[t._v("#")]),t._v(" 封装 vue 组件的过程？")]),t._v(" "),e("ul",[e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("建立组件的模板，先把架子搭起来，写写样式，考虑好组件的基本逻辑。(os：思考1小时，码码10分钟，程序猿的准则。) 　　\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("准备好组件的数据输入。即分析好逻辑，定好 props 里面的数据、类型。　　\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("准备好组件的数据输出。即根据组件逻辑，做好要暴露出来的方法。　　\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("封装完毕了，直接调用即可\n")])])])])]),t._v(" "),e("h2",{attrs:{id:"vue-事件中如何使用-event-对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-事件中如何使用-event-对象"}},[t._v("#")]),t._v(" vue 事件中如何使用 event 对象")]),t._v(" "),e("p",[t._v("获取事件对象，方法参数传递 $event 。注意在事件中要使用 $ 符号")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<button @click="Event($event)">事件对象</button>\n// e.target 是你当前点击的元素\n// e.currentTarget 是你绑定事件的元素\n')])])]),e("h2",{attrs:{id:"vue-修饰符有哪些"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-修饰符有哪些"}},[t._v("#")]),t._v(" Vue 修饰符有哪些")]),t._v(" "),e("p",[t._v("事件修饰符")]),t._v(" "),e("ul",[e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(".stop 阻止事件继续传播\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(".prevent 阻止标签默认行为\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(".capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(".self 只当在 event.target 是当前元素自身时触发处理函数\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(".once 事件将只会触发一次\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(".passive 告诉浏览器你不想阻止事件的默认行为\n")])])]),t._v("v-model 的修饰符")]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(".lazy 通过这个修饰符，转变为在 change 事件再同步\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(".number 自动将用户的输入值转化为数值类型\n")])])])]),t._v(" "),e("li",[e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(".trim 自动过滤用户输入的首尾空格\n")])])]),t._v("键盘事件的修饰符\n.enter\n.tab\n.delete (捕获“删除”和“退格”键)\n.esc\n.space\n.up\n.down\n.left\n.right\n系统修饰键\n.ctrl\n.alt\n.shift\n.meta\n鼠标按钮修饰符\n.left\n.right\n.middle")])]),t._v(" "),e("h2",{attrs:{id:"vue-内置指令"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-内置指令"}},[t._v("#")]),t._v(" Vue 内置指令")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("v-model 多用于表单元素实现双向数据绑定（同 angular 中的 ng-model）")])]),t._v(" "),e("li",[e("p",[t._v("v-bind 动态绑定 作用： 及时对页面的数据进行更改")])]),t._v(" "),e("li",[e("p",[t._v("v-on:click 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在 methods 里面")])]),t._v(" "),e("li",[e("p",[t._v("v-for 格式： v-for=“字段名 in(of) 数组 json” 循环数组或 json(同 angular 中的 ng-repeat)")])]),t._v(" "),e("li",[e("p",[t._v("v-show 显示内容 （同 angular 中的 ng-show）")])]),t._v(" "),e("li",[e("p",[t._v("v-hide 隐藏内容（同 angular 中的 ng-hide）")])]),t._v(" "),e("li",[e("p",[t._v("v-if 显示与隐藏 （dom 元素的删除添加 同 angular 中的 ng-if 默认值为 false）")])]),t._v(" "),e("li",[e("p",[t._v("v-else-if 必须和 v-if 连用")])]),t._v(" "),e("li",[e("p",[t._v("v-else 必须和 v-if 连用 不能单独使用 否则报错 模板编译错误")])]),t._v(" "),e("li",[e("p",[t._v("v-text 解析文本")])]),t._v(" "),e("li",[e("p",[t._v("v-html 解析 html 标签")])]),t._v(" "),e("li",[e("p",[t._v("v-bind:class 三种绑定方法")])]),t._v(" "),e("li",[e("p",[t._v("对象型 ‘{red:isred}’")])]),t._v(" "),e("li",[e("p",[t._v("三元型 ‘isred?“red”:“blue”’")])]),t._v(" "),e("li",[e("p",[t._v("数组型 ‘[{red:“isred”},{blue:“isblue”}]’")])]),t._v(" "),e("li",[e("p",[t._v("v-once 进入页面时 只渲染一次 不在进行渲染")])]),t._v(" "),e("li",[e("p",[t._v("v-cloak 防止闪烁")])]),t._v(" "),e("li",[e("p",[t._v("v-pre 把标签内部的元素原位输出")])])]),t._v(" "),e("h2",{attrs:{id:"前端如何优化网站性能"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端如何优化网站性能"}},[t._v("#")]),t._v(" 前端如何优化网站性能？")]),t._v(" "),e("p",[t._v("代码层面的优化\n对象层级不要过深，否则性能就会差\n不需要响应式的数据不要放到 data 中\n尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher\nv-if 和 v-show 区分使用场景\nv-if 和 v-for 不能连用\ncomputed 和 watch 区分使用场景\nv-for 遍历必须加 key，key 保证唯一\n长列表滚动到可视区域动态加载\n防止内部泄漏，组件销毁后把全局变量和事件销毁\n图片懒加载\n路由懒加载 、异步组件\n第三方插件的按需引入\n适当采用 keep-alive 缓存组件\n防抖、节流运用\nSEO 优化\n服务端渲染 SSR or 预渲染\nWebpack 层面的优化\nWebpack 对图片进行压缩\n压缩代码\n模板预编译\nTree Shaking/Scope Hoisting（摇树优化/作用域提升）\nsplitChunks 提取公共代码\n多线程打包 happypack（作用在 loader 上，使用多个进程同时对文件进行编译）\nsourceMap 优化")]),t._v(" "),e("p",[t._v("基础的 Web 技术的优化\n开启 gzip 压缩\n浏览器缓存\nCDN 的使用\n使用 Chrome Performance 查找性能瓶颈\n用户体验\n骨架屏\nPWA")]),t._v(" "),e("h2",{attrs:{id:"前端有哪几种本地存储方式-简述各自的特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前端有哪几种本地存储方式-简述各自的特点"}},[t._v("#")]),t._v(" 前端有哪几种本地存储方式，简述各自的特点")]),t._v(" "),e("p",[t._v("localStorage、 sessionStorage、 cookie、")]),t._v(" "),e("p",[t._v('共同点：都是保存在浏览器端、且同源的\n区别：\n1、cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间来回传递，而 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存。cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下\n2、存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带 cookie、所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大\n3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的 cookie 过期时间之前有效，即使窗口关闭或浏览器关闭\n4、作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localstorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的\n5、web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者\n6、web Storage 的 api 接口使用更方便\ncookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密），是服务器发送到 web 浏览器的一小块数据，保存在浏览器的一小段文本信息，浏览器进行存储并且下次发送请求的时候携带上 cookie。浏览器每次向服务器发送请求都会携带这段信息。用于判断了两个请求是否来自于同一个浏览器。用户的个性化定制主题，用户的偏好、追踪记录分析用户行为。cookie 数据大小不能超过 4k，\ncookie 设置的 cookie 有效期之前一直有效，即使窗口或浏览器关闭\n存储大小：\nweb storage，浏览器端的缓存方案，保存在客户端，一般不与服务器进行通信交互。存放数据大小一般为 5MB\nsessionStorage 是会话存储，只要浏览器窗口没有关闭，刷新或者重新进入页面数据依然存在。关闭浏览器窗口后数据会被删除；用于敏感账号一次性登录，开屏广告\nlocalStorage 是本地存储，存储持久数据，浏览器关闭后数据不丢失除非主动删除数据，常用于长期登录、判断是否已登录、适合长期保存在本地的数据。\nwebStorage 是以字符串的格式储存的，所以不能直接储存对象和数组类型，需要先转换一下格式再进行储存。\n使用 JSON.stringify()将对象转换成字符串，解析的时候，再使用 JSON.parse()转换回去使用。\n常用方法：\n存：localStorage.setItem("userInfo",JSON.stringify(obj));\n取：var user = JSON.parse(localStorage.getItem("userInfo"))\n删除：localStorage.remove("userInfo);\n清空：localStorage.clear();')]),t._v(" "),e("h2",{attrs:{id:"token"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#token"}},[t._v("#")]),t._v(" Token?")]),t._v(" "),e("p",[t._v("token 是后端传送过来的一段带签名加密的字符串，发送到浏览器存储 cookie，浏览器访问携带 token 访问，可以实现单点登录，而且防止伪造信息，因为签名无法被破解")]),t._v(" "),e("h2",{attrs:{id:"delete-和-vue-delete-删除数组的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#delete-和-vue-delete-删除数组的区别"}},[t._v("#")]),t._v(" delete 和 Vue.delete 删除数组的区别")]),t._v(" "),e("p",[t._v("delete 只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。\nVue.delete 直接删除了数组对应的项，改变了数组的键值。")]),t._v(" "),e("h2",{attrs:{id:"vue-组件-data-为什么必须是函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件-data-为什么必须是函数"}},[t._v("#")]),t._v(" Vue 组件 data 为什么必须是函数")]),t._v(" "),e("p",[t._v("因为 JS 本身的特性带来的，如果 data 是一个对象，那么由于对象本身属于引用类型，当我们修改其中的一个属性时，会影响到所有 Vue 实例的数据。如果将 data 作为一个函数返回一个对象，那么每一个实例的 data 属性都是独立的，不会相互影响了。")]),t._v(" "),e("h2",{attrs:{id:"vue-的单项数据流的理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-的单项数据流的理解"}},[t._v("#")]),t._v(" vue 的单项数据流的理解")]),t._v(" "),e("p",[t._v("单项数据流是指只能从一个方向来修改状态。\n主要应用在父子组件之间的通信。数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父组件的状态，从而导致你的应用的数据流向难以理解。\n注意：在子组件直接用 v-model 绑定父组件传过来的 props 这样是不规范的写法，开发环境会报警告。\n如果实在要改变父组件的 props 值可以再 data 里面定义一个变量，并用 prop 的值初始化它，之后用$emit 通知父组件去修改。")]),t._v(" "),e("h2",{attrs:{id:"v-model-的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#v-model-的原理"}},[t._v("#")]),t._v(" v-model 的原理？")]),t._v(" "),e("p",[t._v("v-model 本质就是一个语法糖，可以看成是 value + input 方法的语法糖。\n可以通过 model 属性的 prop 和 event 属性来进行自定义。原生的 v-model，会根据标签的不同生成不同的事件和属性。\n例如：\ntext 和 textarea 元素使用 value 属性和 input 事件；\ncheckbox 和 radio 使用 checked 属性和 change 事件；\nselect 字段将 value 作为 prop 并将 change 作为事件。\n以 input 表单元素为例：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<input v-model=\'something\'>\n相当于\n<input v-bind:value="something" v-on:input="something = $event.target.value">\n')])])]),e("h2",{attrs:{id:"vue-事件绑定原理说一下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-事件绑定原理说一下"}},[t._v("#")]),t._v(" Vue 事件绑定原理说一下")]),t._v(" "),e("p",[t._v("原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过 Vue 自定义的$on 实现的。")]),t._v(" "),e("h2",{attrs:{id:"assets-和-static-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#assets-和-static-的区别"}},[t._v("#")]),t._v(" assets 和 static 的区别")]),t._v(" "),e("p",[t._v("答：相同点： assets 和 static 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点\n不相同点：assets 中存放的静态资源文件在项目打包时，也就是运行 npm run build 时会将 assets 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 static 文件中跟着 index.html 一同上传至服务器。static 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 static 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 assets 中打包后的文件提交较大点。在服务器中就会占据更大的空间。\n建议： 将项目中 template 需要的样式文件 js 文件等都可以放置在 assets 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如 iconfoont.css 等文件可以放置在 static 中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传。")]),t._v(" "),e("h2",{attrs:{id:"class-与-style-如何动态绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#class-与-style-如何动态绑定"}},[t._v("#")]),t._v(" Class 与 Style 如何动态绑定？")]),t._v(" "),e("p",[t._v("绑定 class 的数组用法 1.对象方法 v-bind:class=\"{'orange':isRipe, 'green':isNotRipe}” 2.数组方法 v-bind:class=\"[class1,class2]\" 3.行内 v-bind:style=\"{color:color,fontSize:fontSize+'px'}”")]),t._v(" "),e("h2",{attrs:{id:"vue-组件的-scoped-属性的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件的-scoped-属性的作用"}},[t._v("#")]),t._v(" vue 组件的 scoped 属性的作用")]),t._v(" "),e("p",[t._v("在 style 标签上添加 scoped 属性，以表示它的样式作用于当下的模块，很好的实现了样式私有化的目的；\nscoped 的实现原理：vue 通过 postcss 给每个 dom 元素添加一个以 data-开头的随机自定义属性实现的。\n但是也得慎用：样式不易（可）修改，而很多时候，我们是需要对公共组件的样式做微调的；\n解决办法：\n①：使用混合型的 css 样式：（混合使用全局跟本地的样式）")]),t._v(" "),e("div",{staticClass:"language-<style> /* 全局样式 */ </style> extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<style scoped> /* 本地样式 */ </style>\n②：深度作用选择器（>>>）如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，可以使用 >>> 操作符：\n<style scoped> .a >>> .b { /* ... */ } </style>\n")])])]),e("h2",{attrs:{id:"怎样理解-vue-的单向数据流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#怎样理解-vue-的单向数据流"}},[t._v("#")]),t._v(" 怎样理解 Vue 的单向数据流")]),t._v(" "),e("p",[t._v("• 数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。\n• 注意：在子组件直接用 v-model 绑定父组件传过来的 prop 这样是不规范的写法 开发环境会报警告\n• 如果实在要改变父组件的 prop 值 可以再 data 里面定义一个变量 并用 prop 的值初始化它 之后用$emit 通知父组件去修改")]),t._v(" "),e("h2",{attrs:{id:"vue-中使用了哪些设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-中使用了哪些设计模式"}},[t._v("#")]),t._v(" vue 中使用了哪些设计模式")]),t._v(" "),e("p",[t._v("1.工厂模式 - 传入参数即可创建实例\n虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode 2.单例模式 - 整个程序有且仅有一个实例\nvuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉 3.发布-订阅模式 (vue 事件机制) 4.观察者模式 (响应式数据原理) 5.装饰模式: (@装饰器的用法) 6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略")]),t._v(" "),e("h2",{attrs:{id:"用-vnode-来描述一个-dom-结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#用-vnode-来描述一个-dom-结构"}},[t._v("#")]),t._v(" 用 VNode 来描述一个 DOM 结构")]),t._v(" "),e("p",[t._v("虚拟节点就是用一个对象来描述一个真实的 DOM 元素。首先将 template （真实 DOM）先转成 ast ，ast 树通过 codegen 生成 render 函数，render 函数里的_c 方法将它转为虚拟 dom")]),t._v(" "),e("h2",{attrs:{id:"prop-验证-和默认值"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#prop-验证-和默认值"}},[t._v("#")]),t._v(" prop 验证，和默认值")]),t._v(" "),e("p",[t._v("我们在父组件给子组件传值得时候，为了避免不必要的错误，可以给 prop 的值进行类型设定，让父组件给子组件传值得时候，更加准确，prop 可以传一个数字，一个布尔值，一个数组，一个对象，以及一个对象的所有属性。组件可以为 props 指定验证要求。如果未指定验证要求，Vue 会发出警告比如传一个 number 类型的数据，用 defalt 设置它的默认值，如果验证失败的话就会发出警告。\nprops: {\nvisible: {\ndefault: true,\ntype: Boolean,\nrequired: true\n},\n}")]),t._v(" "),e("h2",{attrs:{id:"说说你对-spa-单页面的理解-它的优缺点分别是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说说你对-spa-单页面的理解-它的优缺点分别是什么"}},[t._v("#")]),t._v(" 说说你对 SPA 单页面的理解，它的优缺点分别是什么？")]),t._v(" "),e("p",[t._v("SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。\n缺点：\n不支持低版本的浏览器，最低只支持到 IE9；\n不利于 SEO 的优化（如果要支持 SEO，建议通过服务端来进行渲染组件）；\n第一次加载首页耗时相对长一些；\n不可以使用浏览器的导航按钮需要自行实现前进、后退。\n优点：\n无刷新体验,提升了用户体验；\n前端开发不再以页面为单位，更多地采用组件化的思想，代码结构和组织方式更加规范化，便于修改和调整；\nAPI 共享，同一套后端程序代码不用修改就可以用于 Web 界面、手机、平板等多种客户端\n用户体验好、快，内容的改变不需要重新加载整个页面。")]),t._v(" "),e("h2",{attrs:{id:"如何优化-spa-应用的首屏加载速度慢的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何优化-spa-应用的首屏加载速度慢的问题"}},[t._v("#")]),t._v(" 如何优化 SPA 应用的首屏加载速度慢的问题？")]),t._v(" "),e("p",[t._v("1.将公用的 JS 库通过 script 标签外部引入，减小 app.bundel 的大小，让浏览器并行下载资源文件，提高下载速度； 2.在配置 路由时，页面和组件使用懒加载的方式引入，进一步缩小 app.bundel 的体积，在调用某个组件时再加载对应的 js 文件； 3.加一个首屏 loading 图，提升用户体验；")]),t._v(" "),e("h2",{attrs:{id:"vue-中如何监控某个属性值的变化-watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-中如何监控某个属性值的变化-watch"}},[t._v("#")]),t._v(" Vue 中如何监控某个属性值的变化？（watch）")]),t._v(" "),e("p",[t._v("比如现在需要监控 data 中，obj.a 的变化。Vue 中监控对象属性的变化你可以这样：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("watch: {\nobj: {\nhandler (newValue, oldValue) {\nconsole.log('obj changed')\n},\ndeep: true\n}\n}\ndeep属性表示深层遍历，但是这么写会监控obj的所有属性变化，并不是我们想要的效果，所以做点修改：\nwatch: {\n 'obj.a': {\nhandler (newName, oldName) {\nconsole.log('obj.a changed')\n}\n }\n}\n")])])]),e("h2",{attrs:{id:"promise-对象是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#promise-对象是什么"}},[t._v("#")]),t._v(" Promise 对象是什么？")]),t._v(" "),e("p",[t._v("1.Promise 是异步编程的一种解决方案，它是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。promise 对象是一个构造函数，用来生成 Promise 实例；\n2.promise 的两个特点 对象状态不受外界影响 && 一旦状态改变，就不会再变，任何时候都可以得到结果（pending 状态--\x3efulfilled || pending--\x3erejected）")]),t._v(" "),e("h2",{attrs:{id:"常见的-http-状态码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常见的-http-状态码"}},[t._v("#")]),t._v(" 常见的 http 状态码")]),t._v(" "),e("p",[t._v("200 OK 客户端请求成功。\n301 Moved Permanently 请求永久重定向。\n302 Moved Temporarily 请求临时重定向。\n304 Not Modified 文件未修改，可以直接使用缓存的文件。\n400 Bad Request 由于客户端请求有语法错误，不能被服务器所理解。\n401 Unauthorized 请求未经授权，无法访问。\n403 Forbidden 服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因。\n404 Not Found 请求的资源不存在，比如输入了错误的 URL。\n500 Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。\n503 Service Unavailable 服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常。")]),t._v(" "),e("h2",{attrs:{id:"使用过-vue-ssr-吗-说说-ssr"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用过-vue-ssr-吗-说说-ssr"}},[t._v("#")]),t._v(" 使用过 Vue SSR 吗？说说 SSR？")]),t._v(" "),e("p",[t._v('Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记"激活"为客户端上完全可交互的应用程序。\nSSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。\nSSR 有着更好的 SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。还有就是服务器会有更大的负载需求。')]),t._v(" "),e("h2",{attrs:{id:"服务端渲染-ssr-的优缺点如下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染-ssr-的优缺点如下"}},[t._v("#")]),t._v(" 服务端渲染 SSR 的优缺点如下：")]),t._v(" "),e("p",[t._v("（1）服务端渲染的优点：\n• 更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；\n• 更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；\n（2) 服务端渲染的缺点：\n• 更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；\n• 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。Vue 模版编译原理知道吗，能简单说一下吗？")]),t._v(" "),e("h2",{attrs:{id:"vue-模版编译原理知道吗-能简单说一下吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-模版编译原理知道吗-能简单说一下吗"}},[t._v("#")]),t._v(" Vue 模版编译原理知道吗，能简单说一下吗？")]),t._v(" "),e("p",[t._v("简单说，Vue 的编译过程就是将 template 转化为 render 函数的过程。会经历以下阶段：\n• 生成 AST 树\n• 优化\n• codegen\n首先解析模版，生成 AST 语法树(一种用 JavaScript 对象的形式来描述整个模板)。\n使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。\nVue 的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的 DOM 也不会变化。那么优化过程就是深度遍历 AST 树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以跳过对它们的比对，对运行时的模板起到很大的优化作用。\n编译的最后一步是将优化后的 AST 树转换为可执行的代码。\n面试官：(精神小伙啊，有点东西，难度提升，不信难不倒你)")]),t._v(" "),e("h2",{attrs:{id:"再说一下虚拟-dom-以及-key-属性的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#再说一下虚拟-dom-以及-key-属性的作用"}},[t._v("#")]),t._v(" 再说一下虚拟 Dom 以及 key 属性的作用")]),t._v(" "),e("p",[t._v("由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。这就是虚拟 Dom 的产生原因。\nVue2 的 Virtual DOM 借鉴了开源库 snabbdom 的实现。\nVirtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点。是对真实 DOM 的一层抽象。(也就是源码中的 VNode 类，它定义在 src/core/vdom/vnode.js 中。)\nVirtualDOM 映射到真实 DOM 要经历 VNode 的 create、diff、patch 等阶段。\n「key 的作用是尽可能的复用 DOM 元素。」\n新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。\n需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key 也就是 children 中节点的唯一标识。\nkey 的作用是尽可能的复用 DOM 元素。\n新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。\n需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key 也就是 children 中节点的唯一标识。")]),t._v(" "),e("h2",{attrs:{id:"keep-alive-了解吗"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-了解吗"}},[t._v("#")]),t._v(" keep-alive 了解吗")]),t._v(" "),e("p",[t._v("keep-alive 可以实现组件缓存，当组件切换时不会对当前组件进行卸载。\n常用的两个属性 include/exclude，允许组件有条件的进行缓存。\n两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。\nkeep-alive 的中还运用了 LRU(Least Recently Used)算法。\n（又是数据结构与算法，原来算法在前端也有这么多的应用）")]),t._v(" "),e("h2",{attrs:{id:"webpack-的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack-的作用"}},[t._v("#")]),t._v(" webpack 的作用")]),t._v(" "),e("ol",[e("li",[t._v("依赖管理：方便引用第三方模块、让模块更容易复用，避免全局注入导致的冲突、避免重复加载或者加载不需要的模块。会一层一层的读取依赖的模块，添加不同的入口；同时，不会重复打包依赖的模块。")]),t._v(" "),e("li",[t._v("合并代码：把各个分散的模块集中打包成大文件，减少 HTTP 的请求链接数，配合 UglifyJS（压缩代码）可以减少、优化代码的体积。")]),t._v(" "),e("li",[t._v("各路插件：统一处理引入的插件，babel 编译 ES6 文件，TypeScript,eslint 可以检查编译期的错误。\n一句话总结：webpack 的作用就是处理依赖，模块化，打包压缩文件，管理插件。\n一切皆为模块，由于 webpack 只支持 js 文件，所以需要用 loader 转换为 webpack 支持的模块，其中 plugin 用于扩张 webpack 的功能，在 webpack 构建生命周期的过程中，在合适的时机做了合适的事情。")])]),t._v(" "),e("h2",{attrs:{id:"webpack-怎么工作的过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#webpack-怎么工作的过程"}},[t._v("#")]),t._v(" webpack 怎么工作的过程")]),t._v(" "),e("p",[t._v("① 解析配置参数，合并从 shell(npm install 类似的命令)和 webpack.config.js 文件的配置信息，输出最终的配置信息；\n② 注册配置中的插件,让插件监听 webpack 构建生命周期中的事件节点，做出对应的反应；\n③ 解析配置文件中的 entry 入口文件，并找出每个文件依赖的文件，递归下去；\n④ 在递归每个文件的过程中，根据文件类型和配置文件中的 loader 找出对应的 loader 对文件进行转换；\n⑤ 递归结束后得到每个文件最终的结果，根据 entry 配置生成代码 chunk(打包之后的名字)；\n⑥ 输出所以 chunk 到文件系统。")]),t._v(" "),e("h2",{attrs:{id:"如何解决数据层级结构太深的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何解决数据层级结构太深的问题"}},[t._v("#")]),t._v(" 如何解决数据层级结构太深的问题")]),t._v(" "),e("p",[t._v('在开发业务时，经常会岀现异步获取数据的情况，有时数据层次比较深，如以下代码: span \'v-text="a.b.c.d">, 可以使用 vm.$set手动定义一层数据: vm.$set("demo"，a.b.c.d)')]),t._v(" "),e("h2",{attrs:{id:"写过自定义指令吗-原理是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#写过自定义指令吗-原理是什么"}},[t._v("#")]),t._v(" 写过自定义指令吗？原理是什么？")]),t._v(" "),e("p",[t._v("指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。")]),t._v(" "),e("p",[t._v("自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind")]),t._v(" "),e("p",[t._v("1.bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。\n2.inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。\n3.update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。\n4.componentUpdated：被绑定元素所在模板完成一次更新周期时调用。\n5.unbind：只调用一次，指令与元素解绑时调用。")]),t._v(" "),e("p",[t._v("原理 1.在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性 2.通过 genDirectives 生成指令代码 3.在 patch 前将指令的钩子提取到 cbs 中,在 patch 过程中调用对应的钩子 4.当执行指令对应钩子函数时，调用对应指令定义的方法")])])}),[],!1,null,null,null);e.default=r.exports}}]);