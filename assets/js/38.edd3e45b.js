(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{318:function(v,_,e){"use strict";e.r(_);var p=e(13),o=Object(p.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("一、创建地图")]),v._v(" "),_("p",[v._v("1、地图Map")]),v._v(" "),_("p",[v._v("创建地图底图：需要用new ol.Map({})")]),v._v(" "),_("p",[v._v("地图map是由图层layers、一个可视化视图view、用于修改地图内容的交互interaction以及使用UI组件的控件control组成的。")]),v._v(" "),_("p",[v._v("(1)、创建基本地图")]),v._v(" "),_("p",[v._v("let map = new ol.Map({")]),v._v(" "),_("p",[v._v("target: 'map',//对象指向")]),v._v(" "),_("p",[v._v("layers: [//图层")]),v._v(" "),_("p",[v._v("new ol.layer.Tile({//这里定义的是平铺图层")]),v._v(" "),_("p",[v._v("source: new ol.source.OSM()//图层源 定义图层映射协议")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("],")]),v._v(" "),_("p",[v._v("view: new ol.View({//视图")]),v._v(" "),_("p",[v._v("center: ol.proj.fromLonLat([37.41, 8.82]),//地图中心")]),v._v(" "),_("p",[v._v("zoom: 4//缩放层级")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("});")]),v._v(" "),_("p",[v._v("(2)、属性选项")]),v._v(" "),_("p",[v._v("new ol.Map({")]),v._v(" "),_("p",[v._v("target: 'map',//对象映射：要将"),_("code",[v._v("map")]),v._v("对象附加到div，"),_("code",[v._v("map")]),v._v("对象将"),_("code",[v._v("target")]),v._v("作为参数，值是"),_("code",[v._v("div")]),v._v("的"),_("code",[v._v("id")])]),v._v(" "),_("p",[v._v("layers: [//图层")]),v._v(" "),_("p",[v._v("new ol.layer.Tile({//这里定义的是平铺图层")]),v._v(" "),_("p",[v._v("source: new ol.source.OSM()//图层源 定义图层映射协议")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("],")]),v._v(" "),_("p",[v._v("view: new ol.View({//视图")]),v._v(" "),_("p",[v._v("center: ol.proj.fromLonLat([37.41, 8.82]),//地图中心")]),v._v(" "),_("p",[v._v("zoom: 4//缩放层级")]),v._v(" "),_("p",[v._v("}),")]),v._v(" "),_("p",[v._v("controls:[//最初添加到映射中的控件 如未设置 使用默认控件")]),v._v(" "),_("p",[v._v("new ol.control.Control({")]),v._v(" "),_("p",[v._v("element:,//元素是控件的容器元素(DOM)。只有在开发自定义控件时才需要指定这一点")]),v._v(" "),_("p",[v._v("render: ,//控件重新呈现时调用的函数")]),v._v(" "),_("p",[v._v("target: //如果想在映射的视图端口之外呈现控件，指定目标")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("],")]),v._v(" "),_("p",[v._v("interactions:[//最初添加到映射中的交互 如未设置 使用默认交互")]),v._v(" "),_("p",[v._v("new ol.interaction.Interaction({")]),v._v(" "),_("p",[v._v("handleEvent")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("],")]),v._v(" "),_("p",[v._v("overlays:[")]),v._v(" "),_("p",[v._v("new ol.Overlay()")]),v._v(" "),_("p",[v._v("],")]),v._v(" "),_("p",[v._v("maxTilesLoading:16,//同时加载的最大瓷砖数 默认16")]),v._v(" "),_("p",[v._v("loadTilesWhileAnimating:false,//")]),v._v(" "),_("p",[v._v("loadTilesWhileInteracting:false,//")]),v._v(" "),_("p",[v._v("moveTolerance:1,//光标必须移动的最小距离(以像素为单位)才能被检测为map move事件，而不是单击。增加这个值可以使单击地图变得更容易")]),v._v(" "),_("p",[v._v("pixelRatio:window.devicePixelRatio,//")]),v._v(" "),_("p",[v._v("keyboardEventTarget:,//要监听键盘事件的元素")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("(3)、地图事件")]),v._v(" "),_("p",[v._v("地图事件")]),v._v(" "),_("p",[v._v("含义")]),v._v(" "),_("p",[v._v("click")]),v._v(" "),_("p",[v._v("无拖动单击")]),v._v(" "),_("p",[v._v("dblclick")]),v._v(" "),_("p",[v._v("无拖动双击")]),v._v(" "),_("p",[v._v("moveend")]),v._v(" "),_("p",[v._v("移动地图结束时")]),v._v(" "),_("p",[v._v("movestart")]),v._v(" "),_("p",[v._v("移动地图开始时")]),v._v(" "),_("p",[v._v("pointerdrag")]),v._v(" "),_("p",[v._v("当拖动指针时触发")]),v._v(" "),_("p",[v._v("pointermove")]),v._v(" "),_("p",[v._v("当指针移动时触发。注意，在触摸设备上，这是在地图平移时触发的，因此与mousemove不同")]),v._v(" "),_("p",[v._v("postcompose")]),v._v(" "),_("p",[v._v("postrender")]),v._v(" "),_("p",[v._v("在映射帧呈现后触发")]),v._v(" "),_("p",[v._v("precompose")]),v._v(" "),_("p",[v._v("propertychange")]),v._v(" "),_("p",[v._v("当属性被更改时触发")]),v._v(" "),_("p",[v._v("rendercomplete")]),v._v(" "),_("p",[v._v("渲染完成时触发，即当前视图的所有源和tile都已加载完毕，所有tile都将淡出")]),v._v(" "),_("p",[v._v("singleclick")]),v._v(" "),_("p",[v._v("一个真正的无拖放和无双击的单击。注意，这个事件被延迟了250毫秒，以确保它不是双击")]),v._v(" "),_("p",[v._v("(4)、地图方法")]),v._v(" "),_("p",[v._v("地图方法")]),v._v(" "),_("p",[v._v("功能")]),v._v(" "),_("p",[v._v("addControl(control)")]),v._v(" "),_("p",[v._v("将给定的控件添加到地图中")]),v._v(" "),_("p",[v._v("removeControl(control)")]),v._v(" "),_("p",[v._v("从地图中移除已给定的控件")]),v._v(" "),_("p",[v._v("addInteraction(interaction)")]),v._v(" "),_("p",[v._v("将给定的交互添加到地图中")]),v._v(" "),_("p",[v._v("removeInteraction(interaction)")]),v._v(" "),_("p",[v._v("从地图中移除已给定的交互")]),v._v(" "),_("p",[v._v("addLayer(layer)")]),v._v(" "),_("p",[v._v("将给定的图层添加到地图的顶部")]),v._v(" "),_("p",[v._v("removeLayer(layer)")]),v._v(" "),_("p",[v._v("从地图中移除已给定的图层")]),v._v(" "),_("p",[v._v("addOverlay(overlay)")]),v._v(" "),_("p",[v._v("将给定的叠加层添加到地图中")]),v._v(" "),_("p",[v._v("removeOverlay(overlay)")]),v._v(" "),_("p",[v._v("从地图中移除已给定的叠加层")]),v._v(" "),_("p",[v._v("forEachFeatureAtPixel(pixel, callback, opt_options)")]),v._v(" "),_("p",[v._v("检测与视图端口上的像素相交的特性，并对每个相交的特性执行回调。检测中包含的层可以通过opt_options中的layerFilter选项配置")]),v._v(" "),_("p",[v._v("forEachLayerAtPixel(pixel, callback, opt_options)")]),v._v(" "),_("p",[v._v("检测在视图端口上的像素处具有颜色值的层，并对每个匹配的层执行回调。检测中包含的层可以通过opt_layerFilter配置")]),v._v(" "),_("p",[v._v("getControls()")]),v._v(" "),_("p",[v._v("获取地图控件")]),v._v(" "),_("p",[v._v("getCoordinateFromPixel(pixel)")]),v._v(" "),_("p",[v._v("获取给定像素的坐标。这将返回地图视图投影中的坐标。")]),v._v(" "),_("p",[v._v("getEventCoordinate(event)")]),v._v(" "),_("p",[v._v("返回浏览器事件的视图投影中的坐标")]),v._v(" "),_("p",[v._v("getEventPixel(event)")]),v._v(" "),_("p",[v._v("返回浏览器事件相对于视图端口的地图像素位置")]),v._v(" "),_("p",[v._v("getFeaturesAtPixel(pixel, opt_options)")]),v._v(" "),_("p",[v._v("获取视图端口上与像素相交的所有特性")]),v._v(" "),_("p",[v._v("getInteractions()")]),v._v(" "),_("p",[v._v("获取地图交互")]),v._v(" "),_("p",[v._v("getLayerGroup()")]),v._v(" "),_("p",[v._v("获取与此地图关联的图层组")]),v._v(" "),_("p",[v._v("setLayerGroup(layerGroup)")]),v._v(" "),_("p",[v._v("设置与此地图关联的图层组")]),v._v(" "),_("p",[v._v("getLayers()")]),v._v(" "),_("p",[v._v("获取与此地图关联的图层的集合")]),v._v(" "),_("p",[v._v("getOverlayById(id)")]),v._v(" "),_("p",[v._v("通过其标识符获取覆盖(overlay. getId()返回的值)。注意，索引将字符串和数字标识符视为相同的。getoverlaybyid(2)将返回id为2或2的叠加层。")]),v._v(" "),_("p",[v._v("getOverlays()")]),v._v(" "),_("p",[v._v("获得地图叠加")]),v._v(" "),_("p",[v._v("getPixelFromCoordinate(coordinate)")]),v._v(" "),_("p",[v._v("获取坐标的像素。它接受地图视图投影中的坐标并返回相应的像素")]),v._v(" "),_("p",[v._v("getSize()")]),v._v(" "),_("p",[v._v("获取地图尺寸")]),v._v(" "),_("p",[v._v("setSize(size)")]),v._v(" "),_("p",[v._v("s设置地图尺寸")]),v._v(" "),_("p",[v._v("getTarget()")]),v._v(" "),_("p",[v._v("获取呈现此映射的目标。注意，这将返回作为选项或setTarget中输入的内容。如果这是一个元素，它将返回一个元素;如果是字符串，它会返回这个字符串")]),v._v(" "),_("p",[v._v("setTarget(target)")]),v._v(" "),_("p",[v._v("设置要将地图呈现的目标元素")]),v._v(" "),_("p",[v._v("getTargetElement()")]),v._v(" "),_("p",[v._v("获取呈现此映射的DOM元素。与getTarget相反，这个方法总是返回一个元素，如果映射没有目标，则返回null")]),v._v(" "),_("p",[v._v("getView()")]),v._v(" "),_("p",[v._v("获取地图视图。视图管理中心和分辨率等属性。")]),v._v(" "),_("p",[v._v("setView(view)")]),v._v(" "),_("p",[v._v("设置地图视图")]),v._v(" "),_("p",[v._v("getViewport()")]),v._v(" "),_("p",[v._v("获取作为map视图端口的元素")]),v._v(" "),_("p",[v._v("hasFeatureAtPixel(pixel, opt_options)")]),v._v(" "),_("p",[v._v("检测在viewport上是否与一个像素相交。可以通过opt_layerFilter配置在检测中包含的层。")]),v._v(" "),_("p",[v._v("2、图层Layers")]),v._v(" "),_("p",[v._v("定义图层：地图图层layers:[...]组定义映射中可用的图层组，用来盛放地图上的各种元素，其在地图上的显示顺序是按照数组中元素序列从下到上呈现的，可以直接在创建地图时定义图层，多个图层的时候可以单独定义。")]),v._v(" "),_("p",[v._v("const layer = new ol.layer.Vector({//这里定义的是图层类型(Image/Title/Vector)")]),v._v(" "),_("p",[v._v("source:new ol.source.Vector(),//矢量图层源 源是用于获取映射块的协议【必须】")]),v._v(" "),_("p",[v._v("style:[],//图层样式 【必须】")]),v._v(" "),_("p",[v._v("feature:[],//图层元素 【必须】")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("添加指定图层：map.addLayer(layer)；")]),v._v(" "),_("p",[v._v("移除指定图层：map.removeLayer(layer)；")]),v._v(" "),_("p",[v._v("图层是轻量级容器，从数据源Source获取数据。")]),v._v(" "),_("p",[v._v("Sourced子类分别有，分别对应不同图层类：")]),v._v(" "),_("p",[v._v("ol.source.ImageSource()")]),v._v(" "),_("p",[v._v("ol.source.TileSource()")]),v._v(" "),_("p",[v._v("ol.source.VectorSource()")]),v._v(" "),_("p",[v._v("Source主要有以下属性选项：")]),v._v(" "),_("p",[v._v("new ol.source.VectorSource({")]),v._v(" "),_("p",[v._v("attributions:,//")]),v._v(" "),_("p",[v._v("attributionsCollapsible:,//布尔值 默认为true")]),v._v(" "),_("p",[v._v("projection:,//投影系")]),v._v(" "),_("p",[v._v("state:'ready',//默认为'ready'")]),v._v(" "),_("p",[v._v("wrapX:false,//默认为false")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("ol.layer.Tile()和ol.layer.Image()图层类都具有相同的属性如下：")]),v._v(" "),_("p",[v._v("new ol.layer.Tile/Image({//以下为图层的属性选项， 都可设置，所以皆有getter/setter")]),v._v(" "),_("p",[v._v("opacity:2,//透明度 区间范围为(0, 1) 默认为1")]),v._v(" "),_("p",[v._v("visible:true,//显示属性 布尔值 默认为true")]),v._v(" "),_("p",[v._v("extent:[],//图层渲染的边界范围。该层将不会在此范围之外呈现")]),v._v(" "),_("p",[v._v("zIndex:2,//图层渲染的索引层级。在渲染时，图层将被排序，首先是z-idnex，然后是位置，当为undefined时，对于添加到映射的layers集合中的层，zIndex为0，或者当使用该层的setMap()方法时，zIndex为无穷大")]),v._v(" "),_("p",[v._v("minResolution:3,//该层可见的最小分辨率(包括在内)")]),v._v(" "),_("p",[v._v("maxResolution:6,//该层可见的最大分辨率(包括在内)")]),v._v(" "),_("p",[v._v("repload:0,//预加载。将低分辨率瓦片加载到预加载级别。0表示没有预加载 默认为0")]),v._v(" "),_("p",[v._v("source:new ol.source.TileSource()/ImageSource(),//图层源")]),v._v(" "),_("p",[v._v("map: ,//把图层覆盖在地图上，地图不会在它的图层集合中管理这个图层，这个图层将被呈现在顶部，这对于临时层非常有用。")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("(1)ol.layer.Tile()")]),v._v(" "),_("p",[v._v("平铺图层。")]),v._v(" "),_("p",[v._v("对于提供预呈现、平铺的网格图像的层源，这些网格按特定分辨率的缩放级别组织。")]),v._v(" "),_("p",[v._v("(2)ol.layer.Image()")]),v._v(" "),_("p",[v._v("图像图层。")]),v._v(" "),_("p",[v._v("服务器呈现的映像，可用于任意范围和分辨率。")]),v._v(" "),_("p",[v._v("(3)ol.layer.Vector()")]),v._v(" "),_("p",[v._v("矢量图层。")]),v._v(" "),_("p",[v._v("在客户端呈现矢量数据，其属性具备getter和setter")]),v._v(" "),_("p",[v._v("new ol.layer.Vector({//以下为图层的属性选项， 都可设置，所以皆有getter/setter")]),v._v(" "),_("p",[v._v("opacity:2,//透明度 区间范围为(0, 1) 默认为1")]),v._v(" "),_("p",[v._v("visible:true,//显示属性 布尔值 默认为true")]),v._v(" "),_("p",[v._v("extent:[],//图层渲染的边界范围。该层将不会在此范围之外呈现")]),v._v(" "),_("p",[v._v("zIndex:2,//图层渲染的索引层级。在渲染时，图层将被排序，首先是z-idnex，然后是位置，当为undefined时，对于添加到映射的layers集合中的层，zIndex为0，或者当使用该层的setMap()方法时，zIndex为无穷大")]),v._v(" "),_("p",[v._v("minResolution:3,//该层可见的最小分辨率(包括在内)")]),v._v(" "),_("p",[v._v("maxResolution:6,//该层可见的最大分辨率(包括在内)")]),v._v(" "),_("p",[v._v("renderOrder:,//呈现顺序。函数用于在呈现前对特性进行排序。默认情况下，特性是按照创建它们的顺序绘制的。使用null来避免排序，但是得到一个未定义的绘制顺序")]),v._v(" "),_("p",[v._v("renderBuffer:100,//默认为100 缓冲区")]),v._v(" "),_("p",[v._v("renderMode:'vector',//默认为'vector' 矢量图层的渲染模式")]),v._v(" "),_("p",[v._v("source:new ol.source.VectorSource(),//图层源")]),v._v(" "),_("p",[v._v("map: ,//把图层覆盖在地图上，地图不会在它的图层集合中管理这个图层，这个图层将被呈现在顶部，这对于临时层非常有用")]),v._v(" "),_("p",[v._v("declutter:false,//默认为false 整理图片和文字。清理应用于所有图像和文本样式，优先级由样式的z-index定义。z-index指数越低，优先级越高")]),v._v(" "),_("p",[v._v("style:new ol.style.Style(),//图层样式")]),v._v(" "),_("p",[v._v("updateWhileAnimating:false,//默认为false")]),v._v(" "),_("p",[v._v("updateWhileInteracting:false,//默认为false")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("其中渲染模式有两种：")]),v._v(" "),_("p",[v._v("'image'：矢量图层被渲染为图像。性能很好，但是点符号和文本总是随着视图旋转，像素在缩放动画中缩放")]),v._v(" "),_("p",[v._v("'vector'：矢量图层被呈现为向量。即使在动画期间也有最准确的渲染，但性能较慢")]),v._v(" "),_("p",[v._v("1)Feature")]),v._v(" "),_("p",[v._v("用于地理特征的矢量元素，具有几何geometry()和其他属性，类似于矢量文件格式(如GeoJSON)中的特性。")]),v._v(" "),_("p",[v._v("添加矢量元素：通过vectorsource().addFeature(feature)添加到矢量图层上。")]),v._v(" "),_("p",[v._v("移除图层所有的矢量元素：vectorsource().clear()")]),v._v(" "),_("p",[v._v("let feature = new ol.Feature({")]),v._v(" "),_("p",[v._v("geometry: new ol.geom.Polygon(polyCoords),")]),v._v(" "),_("p",[v._v("labelPoint: new ol.geom.Point(labelCoords),")]),v._v(" "),_("p",[v._v("style:new ol.style.Style({}),")]),v._v(" "),_("p",[v._v("name: 'My Polygon'")]),v._v(" "),_("p",[v._v("});")]),v._v(" "),_("p",[v._v("定义矢量元素：new ol.Feature()，；")]),v._v(" "),_("p",[v._v("矢量元素样式：")]),v._v(" "),_("p",[v._v("设置样式：new ol.style.Style()，也可以使用feature.setStyle(style)，未定义的话，可以使用它的盛放容器layer的样式；")]),v._v(" "),_("p",[v._v("获取样式：feature.getStyle()")]),v._v(" "),_("p",[v._v("一个feature只有一个默认几何属性geometry，可以有任意数量的命名几何图形：")]),v._v(" "),_("p",[v._v("获取默认几何属性：feature.getGeometry()；")]),v._v(" "),_("p",[v._v("设置几何属性：feature.setGeometry(geometry)；")]),v._v(" "),_("p",[v._v("设置几何属性名：feature.setGeometryName(name)；")]),v._v(" "),_("p",[v._v("矢量元素要呈现的几何图形的特征属性、几何图形或函数由geometry属性选项设定，主要有以下几种子类模块：")]),v._v(" "),_("p",[v._v("ol.geom.Circle()：圆形")]),v._v(" "),_("p",[v._v("ol.geom.Geometry()：几何图形")]),v._v(" "),_("p",[v._v("ol.geom.GeometryCollection()：")]),v._v(" "),_("p",[v._v("ol.geom.LinearRing()：环线")]),v._v(" "),_("p",[v._v("ol.geom.LineString()：线段")]),v._v(" "),_("p",[v._v("ol.geom.Point()：点")]),v._v(" "),_("p",[v._v("ol.geom.Polygon()：多边形")]),v._v(" "),_("p",[v._v("ol.geom.MultiLineString()")]),v._v(" "),_("p",[v._v("ol.geom.MultiPoint()")]),v._v(" "),_("p",[v._v("ol.geom.MultiPolygon()")]),v._v(" "),_("p",[v._v("ol.geom.SimpleGeometry()")]),v._v(" "),_("p",[v._v("feature的稳定标识符ID：")]),v._v(" "),_("p",[v._v("设置feature的id：feature.setId(id)，当id可能相同时，可以这样加以区分")]),v._v(" "),_("p",[v._v('feature.setId(id + "featureName");')]),v._v(" "),_("p",[v._v("获取feature的id：vector.getSource().getFeatureById()或者vectorsource().getFeatureById()")]),v._v(" "),_("p",[v._v("feature的set(key, value, opt_silent)：")]),v._v(" "),_("p",[v._v('设置key：feature.set("keyName",name)，keyName是字符串，自己根据情况设置')]),v._v(" "),_("p",[v._v('获取key：之前设置的什么，就获取什么，feature.get("keyName")，会得到设置的值')]),v._v(" "),_("p",[v._v("2)Style")]),v._v(" "),_("p",[v._v("矢量特征呈现样式的容器。在重新呈现使用样式的特性或图层之前，通过set*()方法对样式及其子元素所做的任何更改都不会生效。")]),v._v(" "),_("p",[v._v("new ol.style.Style({")]),v._v(" "),_("p",[v._v("geometry:new ol.geom.LineString(),//有以上ol.geom模块的几何图形可以参考")]),v._v(" "),_("p",[v._v("fill:new ol.style.Fill({//填充样式")]),v._v(" "),_("p",[v._v("color:color//颜色、渐变或图案")]),v._v(" "),_("p",[v._v("}),")]),v._v(" "),_("p",[v._v("image:new ol.style.Image({//图像")]),v._v(" "),_("p",[v._v("opacity:,//数值")]),v._v(" "),_("p",[v._v("rotateWithView:,//布尔值")]),v._v(" "),_("p",[v._v("rotation:,//数值")]),v._v(" "),_("p",[v._v("scale://数值")]),v._v(" "),_("p",[v._v("}),")]),v._v(" "),_("p",[v._v("image:new ol.style.Icon({//可以使用图片资源")]),v._v(" "),_("p",[v._v("anchor:[0.5，0.5]，//锚。默认值是图标中心 默认值是[0.5,0.5]")]),v._v(" "),_("p",[v._v("anchorOrigin:'top-left',//锚的原点:左下角、右下角、左上方或右上方。默认是左上")]),v._v(" "),_("p",[v._v("anchorXUnits:'fraction',//指定锚点x值的单位。'fraction'的值表示x值是图标的'fraction'。'pixels'的值表示像素中的x值,默认为'fraction'")]),v._v(" "),_("p",[v._v("anchorYUnits:'fraction',//指定锚点y值的单位。'fraction'的值表示y值是图标的'fraction'。'pixels'的值表示像素中的y值,默认为'fraction'")]),v._v(" "),_("p",[v._v("color:color,//颜色、渐变或图案")]),v._v(" "),_("p",[v._v("crossOrigin:,")]),v._v(" "),_("p",[v._v("img:,//图标的图像对象 如果没有提供src选项，则必须已经加载了提供的图像")]),v._v(" "),_("p",[v._v("imgSize:,//")]),v._v(" "),_("p",[v._v("offset:[0,0].//偏移值，默认为[0,0]")]),v._v(" "),_("p",[v._v("offsetOrigin:'top-left',//偏移量的原点，bottom-left, bottom-right, top-left or top-right. 默认是"),_("code",[v._v("top-left")])]),v._v(" "),_("p",[v._v("opacity:1,//默认是1 (0，1)")]),v._v(" "),_("p",[v._v("scale:1,//默认是1")]),v._v(" "),_("p",[v._v("rotation：0，//以弧度旋转(顺时针方向正旋转) 默认为0")]),v._v(" "),_("p",[v._v("size：,//图标大小(以像素为单位)。可与偏移量一起用于定义要从原点(sprite)图标图像使用的子矩形")]),v._v(" "),_("p",[v._v("src:'',//图像URL源")]),v._v(" "),_("p",[v._v("rotateWithView：false,//是否旋转视图中的图标 默认为false")]),v._v(" "),_("p",[v._v("}),")]),v._v(" "),_("p",[v._v("stroke:new ol.style.Stroke({//描绘")]),v._v(" "),_("p",[v._v("width: ,//宽")]),v._v(" "),_("p",[v._v("color:color,//颜色、渐变或图案")]),v._v(" "),_("p",[v._v("lineCap:'round',//线帽风格 butt, round, 或者 square 默认 round")]),v._v(" "),_("p",[v._v("lineJoin:'round',//线连接方式 bevel, round, 或者 miter 默认 round")]),v._v(" "),_("p",[v._v("lineDash： []，//线间隔模式 这个变化与分辨率有关 默认为undefined Internet Explorer 10和更低版本不支持")]),v._v(" "),_("p",[v._v("lineDashOffset:0,//线段间隔偏移 默认0")]),v._v(" "),_("p",[v._v("miterLimit:10,// 默认10")]),v._v(" "),_("p",[v._v("}),")]),v._v(" "),_("p",[v._v("text:new ol.style.Text({//文字")]),v._v(" "),_("p",[v._v("font:'',//默认是'10px sans-serif'")]),v._v(" "),_("p",[v._v("text:'',//文本内容")]),v._v(" "),_("p",[v._v("textAlign：'center',//文本对齐 'left', 'right', 'center', 'end' 'start'.针对于placement: 'point',默认为'center'；针对于placement: 'line'，默认是让渲染器选择不超过maxAngle的位置")]),v._v(" "),_("p",[v._v("textBaseline:'middle',//文本基线 'bottom', 'top', 'middle', 'alphabetic', 'hanging', 'ideographic' 默认'middle'")]),v._v(" "),_("p",[v._v("placement:'',//文本布置")]),v._v(" "),_("p",[v._v("scale：，")]),v._v(" "),_("p",[v._v("padding:[0,0,0,0],//文本周围的像素填充。数组中值的顺序是[top, right, bottom, left]")]),v._v(" "),_("p",[v._v("fill:new ol.style.Fill(),//如果未设置，默认未#333")]),v._v(" "),_("p",[v._v("stroke:new ol.style.Stroke(),")]),v._v(" "),_("p",[v._v("offsetX:0,//水平文本偏移量(以像素为单位)。正值将把文本右移。默认0")]),v._v(" "),_("p",[v._v("offsetY:0,//垂直文本偏移量(以像素为单位)。正值会将文本向下移动。默认0")]),v._v(" "),_("p",[v._v("rotation：0，//默认0")]),v._v(" "),_("p",[v._v("rotateWithView:false,")]),v._v(" "),_("p",[v._v("backgroundFill: ,//当placement:“point”时，填充文本背景的样式。默认为无填充")]),v._v(" "),_("p",[v._v("backgroundStroke: ,//当placement:“point”时，描绘文本背景的样式。默认为无描绘")]),v._v(" "),_("p",[v._v("}),")]),v._v(" "),_("p",[v._v("zIndex:,")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("ol.geom.Geomtry()是矢量几何对象的抽象基类，通常只用于创建子类，而不是在应用程序中实例化。它的方法如下：")]),v._v(" "),_("p",[v._v("方法")]),v._v(" "),_("p",[v._v("功能")]),v._v(" "),_("p",[v._v("set(key, value)")]),v._v(" "),_("p",[v._v("设置值。key：关键名字(字符串)；value：值")]),v._v(" "),_("p",[v._v("get(key)")]),v._v(" "),_("p",[v._v("获取值")]),v._v(" "),_("p",[v._v("setProperties(values, opt_silent)")]),v._v(" "),_("p",[v._v("设置键值对的集合。注意，这将更改任何现有属性并添加新属性(它不会删除任何现有属性)。")]),v._v(" "),_("p",[v._v("getProperties()")]),v._v(" "),_("p",[v._v("获取一个包含所有属性名和值的对象")]),v._v(" "),_("p",[v._v("getClosestPoint(point, opt_closestPoint)")]),v._v(" "),_("p",[v._v("将几何图形的最近点作为坐标返回到经过的点")]),v._v(" "),_("p",[v._v("getExtent(opt_extent)")]),v._v(" "),_("p",[v._v("获取几何的范围")]),v._v(" "),_("p",[v._v("getKeys()")]),v._v(" "),_("p",[v._v("获取对象属性名称列表")]),v._v(" "),_("p",[v._v("getRevision()")]),v._v(" "),_("p",[v._v("获取此对象的版本号。每次修改对象时，它的版本号都会增加。")]),v._v(" "),_("p",[v._v("intersectsCoordinate(coordinate)")]),v._v(" "),_("p",[v._v("如果该几何图形包含指定的坐标，则返回true。如果坐标位于几何图形的边界上，则返回false")]),v._v(" "),_("p",[v._v("rotate(angle, anchor)")]),v._v(" "),_("p",[v._v("围绕给定的坐标旋转几何图形。这将修改现有的几何坐标")]),v._v(" "),_("p",[v._v("scale(sx, opt_sy, opt_anchor)")]),v._v(" "),_("p",[v._v("缩放几何图形(可选原点)。这将修改现有的几何坐标。sx：x方向上的缩放因子；sy：Y轴上的缩放因子；opt_anchor`：缩放原点(默认为几何范围的中心)")]),v._v(" "),_("p",[v._v("simplify(tolerance)")]),v._v(" "),_("p",[v._v("创建这个几何图形的简化版本")]),v._v(" "),_("p",[v._v("transform(source, destination)")]),v._v(" "),_("p",[v._v("将圆的每个坐标从一个坐标系变换到另一个坐标系。在适当的位置修改几何图形。如果不想修改几何图形，请首先clone()它，然后在克隆上使用此函数。在内部，一个圆目前由两点表示:圆心[cx, cy]和圆心右边的点[cx + r, cy]。这个transform函数只变换这两点。所以得到的几何形状也是一个圆，而这个圆并不等同于通过变换原圆的每一点得到的形状")]),v._v(" "),_("p",[v._v("translate(deltaX, deltaY)")]),v._v(" "),_("p",[v._v("翻转几何图形。这将修改现有的几何坐标。如果您想要一个新的几何体，那么首先clone()这个几何体")]),v._v(" "),_("p",[v._v("以下是ol.geom.Geomtry抽象基类创建的常见子类模块：")]),v._v(" "),_("p",[v._v("1)ol.geom.Circle()")]),v._v(" "),_("p",[v._v("new ol.geom.Circle({")]),v._v(" "),_("p",[v._v("center:[],//中心点")]),v._v(" "),_("p",[v._v("radius:2,//圆半径")]),v._v(" "),_("p",[v._v("layout://布局")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("方法")]),v._v(" "),_("p",[v._v("功能")]),v._v(" "),_("p",[v._v("applyTransform(transformFn)")]),v._v(" "),_("p",[v._v("对几何图形的每个坐标应用一个变换函数。在适当的位置修改几何图形。如果不想修改几何图形，请首先clone()它，然后在克隆上使用此函数")]),v._v(" "),_("p",[v._v("clone()")]),v._v(" "),_("p",[v._v("把几何图形复制一份")]),v._v(" "),_("p",[v._v("getCenter()")]),v._v(" "),_("p",[v._v("返回中心坐标")]),v._v(" "),_("p",[v._v("getFirstCoordinate()")]),v._v(" "),_("p",[v._v("返回几何图形的第一个坐标")]),v._v(" "),_("p",[v._v("getLastCoordinate()")]),v._v(" "),_("p",[v._v("返回几何图形的最后一个坐标")]),v._v(" "),_("p",[v._v("getLayout()")]),v._v(" "),_("p",[v._v("返回几何图形的layout")]),v._v(" "),_("p",[v._v("getRadius()")]),v._v(" "),_("p",[v._v("返回圆的半径")]),v._v(" "),_("p",[v._v("getType()")]),v._v(" "),_("p",[v._v("获取这个几何图形的类型")]),v._v(" "),_("p",[v._v("intersectsExtent(extent)")]),v._v(" "),_("p",[v._v("测试几何形状和经过的区域是否相交，返回布尔值")]),v._v(" "),_("p",[v._v("rotate(angle, anchor)")]),v._v(" "),_("p",[v._v("围绕给定的坐标旋转几何图形。这将修改现有的几何坐标。angle：以弧度为单位的旋转角度；anchor：旋转中心")]),v._v(" "),_("p",[v._v("scale(sx, opt_sy, opt_anchor)")]),v._v(" "),_("p",[v._v("缩放几何图形(可选原点)。这将修改现有的几何坐标。sx：x方向上的缩放因子；sy：Y轴上的缩放因子；opt_anchor：缩放原点(默认为几何范围的中心)")]),v._v(" "),_("p",[v._v("setCenter(center)")]),v._v(" "),_("p",[v._v("将圆心设置为coordinate")]),v._v(" "),_("p",[v._v("setCenterAndRadius(center, radius, opt_layout)")]),v._v(" "),_("p",[v._v("设置圆的中心(coordinate)和半径(number)")]),v._v(" "),_("p",[v._v("setRadius(radius)")]),v._v(" "),_("p",[v._v("设置圆的半径。半径的单位是投影的单位。")]),v._v(" "),_("p",[v._v("transform(source, destination)")]),v._v(" "),_("p",[v._v("将圆的每个坐标从一个坐标系变换到另一个坐标系。在适当的位置修改几何图形。如果不想修改几何图形，请首先clone()它，然后在克隆上使用此函数。在内部，一个圆目前由两点表示:圆心[cx, cy]和圆心右边的点[cx + r, cy]。这个transform函数只变换这两点。所以得到的几何形状也是一个，而这个圆并不等同于通过变换原圆的每一点得到的形状")]),v._v(" "),_("p",[v._v("translate(deltaX, deltaY)")]),v._v(" "),_("p",[v._v("f翻转几何图形。这将修改现有的几何坐标。如果您想要一个新的几何体，那么首先clone()这个几何体")]),v._v(" "),_("p",[v._v("2)ol.geom.LineString(coordinates, opt_layout)")]),v._v(" "),_("p",[v._v("new ol.geom.LineString({")]),v._v(" "),_("p",[v._v("coordinate:[],//坐标。对于内部使用，平面坐标结合opt_layout也可以接受")]),v._v(" "),_("p",[v._v("layout: //Layout")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("方法")]),v._v(" "),_("p",[v._v("功能")]),v._v(" "),_("p",[v._v("appendCoordinate(coordinate)")]),v._v(" "),_("p",[v._v("将经过的坐标追加到linestring的坐标里")]),v._v(" "),_("p",[v._v("applyTransform(transformFn)")]),v._v(" "),_("p",[v._v("对几何图形的每个坐标应用一个变换函数。在适当的位置修改几何图形。如果不想修改几何图形，请首先clone()它，然后在克隆上使用此函数")]),v._v(" "),_("p",[v._v("clone()")]),v._v(" "),_("p",[v._v("把几何图形复制一份")]),v._v(" "),_("p",[v._v("forEachSegment(callback)")]),v._v(" "),_("p",[v._v("遍历每条线段，调用提供的回调函数。如果回调函数返回一个真值，则函数立即返回该值。否则函数返回false")]),v._v(" "),_("p",[v._v("getCoordinateAt(fraction, opt_dest)")]),v._v(" "),_("p",[v._v("沿着线段返回给定部分的坐标。fraction是一个介于0和1之间的数字，其中0是线段的开始，1是线段的末尾")]),v._v(" "),_("p",[v._v("getCoordinates()")]),v._v(" "),_("p",[v._v("返回线段的坐标")]),v._v(" "),_("p",[v._v("setCoordinates(coordinates, opt_layout)")]),v._v(" "),_("p",[v._v("s设置线段的坐标")]),v._v(" "),_("p",[v._v("getFirstCoordinate()")]),v._v(" "),_("p",[v._v("返回几何图形的第一个坐标")]),v._v(" "),_("p",[v._v("getLastCoordinate()")]),v._v(" "),_("p",[v._v("返回几何图形的最后一个坐标")]),v._v(" "),_("p",[v._v("getLayout()")]),v._v(" "),_("p",[v._v("返回几何图形的Layout")]),v._v(" "),_("p",[v._v("getLength()")]),v._v(" "),_("p",[v._v("在投影平面上返回线段的长度")]),v._v(" "),_("p",[v._v("getType()")]),v._v(" "),_("p",[v._v("得到这个几何图形的类型")]),v._v(" "),_("p",[v._v("intersectsExtent(extent)")]),v._v(" "),_("p",[v._v("测试几何形状和通过的范围是否相交")]),v._v(" "),_("p",[v._v("rotate(angle, anchor)")]),v._v(" "),_("p",[v._v("围绕给定的坐标旋转几何图形。这将修改现有的几何坐标")]),v._v(" "),_("p",[v._v("scale(sx, opt_sy, opt_anchor)")]),v._v(" "),_("p",[v._v("缩放几何图形(可选原点)。这将修改现有的几何坐标。sx：x方向上的缩放因子；sy：Y轴上的缩放因子；opt_anchor`：缩放原点(默认为几何范围的中心)")]),v._v(" "),_("p",[v._v("translate(deltaX, deltaY)")]),v._v(" "),_("p",[v._v("翻转几何图形。这将修改现有的几何坐标。如果您想要一个新的几何体，那么首先clone()这个几何体")]),v._v(" "),_("p",[v._v("3)ol.geom.Point(coordinates, opt_layout)")]),v._v(" "),_("p",[v._v("new ol.geom.Point()")]),v._v(" "),_("p",[v._v("方法")]),v._v(" "),_("p",[v._v("功能")]),v._v(" "),_("p",[v._v("applyTransform(transformFn)")]),v._v(" "),_("p",[v._v("对几何图形的每个坐标应用一个变换函数。在适当的位置修改几何图形。如果不想修改几何图形，请首先clone()它，然后在克隆上使用此函数")]),v._v(" "),_("p",[v._v("clone()")]),v._v(" "),_("p",[v._v("把几何图形复制一份")]),v._v(" "),_("p",[v._v("getCoordinates()")]),v._v(" "),_("p",[v._v("返回点的坐标")]),v._v(" "),_("p",[v._v("setCoordinates(coordinates, opt_layout)")]),v._v(" "),_("p",[v._v("设置点的坐标")]),v._v(" "),_("p",[v._v("getFirstCoordinate()")]),v._v(" "),_("p",[v._v("返回几何图形的第一个坐标")]),v._v(" "),_("p",[v._v("getLastCoordinate()")]),v._v(" "),_("p",[v._v("返回几何图形的最后一个坐标")]),v._v(" "),_("p",[v._v("getLayout()")]),v._v(" "),_("p",[v._v("返回几何图形的Layout")]),v._v(" "),_("p",[v._v("getType()")]),v._v(" "),_("p",[v._v("得到这个几何图形的类型")]),v._v(" "),_("p",[v._v("intersectsExtent(extent)")]),v._v(" "),_("p",[v._v("测试几何形状和通过的范围是否相交")]),v._v(" "),_("p",[v._v("rotate(angle, anchor)")]),v._v(" "),_("p",[v._v("围绕给定的坐标旋转几何图形。这将修改现有的几何坐标")]),v._v(" "),_("p",[v._v("scale(sx, opt_sy, opt_anchor)")]),v._v(" "),_("p",[v._v("缩放几何图形(可选原点)。这将修改现有的几何坐标。sx：x方向上的缩放因子；sy：Y轴上的缩放因子；opt_anchor`：缩放原点(默认为几何范围的中心)")]),v._v(" "),_("p",[v._v("translate(deltaX, deltaY)")]),v._v(" "),_("p",[v._v("翻转几何图形。这将修改现有的几何坐标。如果您想要一个新的几何体，那么首先clone()这个几何体")]),v._v(" "),_("p",[v._v("(4)ol.geom.Polygon()")]),v._v(" "),_("p",[v._v("多边形几何图形。")]),v._v(" "),_("p",[v._v("new ol.geom.Polygon({")]),v._v(" "),_("p",[v._v("coordinates:[],//定义多边形的线性环的数组")]),v._v(" "),_("p",[v._v("layout:,")]),v._v(" "),_("p",[v._v("ends:[],//末端(平面坐标内部使用)")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("方法")]),v._v(" "),_("p",[v._v("功能")]),v._v(" "),_("p",[v._v("applyTransform(transformFn)")]),v._v(" "),_("p",[v._v("对几何图形的每个坐标应用一个变换函数。在适当的位置修改几何图形。如果不想修改几何图形，请首先clone()它，然后在克隆上使用此函数")]),v._v(" "),_("p",[v._v("appendLinearRing(linearRing)")]),v._v(" "),_("p",[v._v("在多边形上追加线性环")]),v._v(" "),_("p",[v._v("clone()")]),v._v(" "),_("p",[v._v("把几何图形复制一份")]),v._v(" "),_("p",[v._v("getCoordinates()")]),v._v(" "),_("p",[v._v("返回点的坐标")]),v._v(" "),_("p",[v._v("setCoordinates(coordinates, opt_layout)")]),v._v(" "),_("p",[v._v("设置点的坐标")]),v._v(" "),_("p",[v._v("getFirstCoordinate()")]),v._v(" "),_("p",[v._v("返回几何图形的第一个坐标")]),v._v(" "),_("p",[v._v("getLastCoordinate()")]),v._v(" "),_("p",[v._v("返回几何图形的最后一个坐标")]),v._v(" "),_("p",[v._v("getInteriorPoint()")]),v._v(" "),_("p",[v._v("返回多边形的内部点")]),v._v(" "),_("p",[v._v("getLinearRing(index)")]),v._v(" "),_("p",[v._v("返回多边形几何的第n个线性环。如果给定索引超出范围，则返回null。外部线性环在索引0处可用，而内部环在索引1及以上处可用")]),v._v(" "),_("p",[v._v("getLinearRings()")]),v._v(" "),_("p",[v._v("返回多边形的线性环")]),v._v(" "),_("p",[v._v("getLinearRingCount()")]),v._v(" "),_("p",[v._v("返回多边形的环数，这包括外部环和任何内部环")]),v._v(" "),_("p",[v._v("getLayout()")]),v._v(" "),_("p",[v._v("返回几何图形的Layout")]),v._v(" "),_("p",[v._v("getType()")]),v._v(" "),_("p",[v._v("得到这个几何图形的类型")]),v._v(" "),_("p",[v._v("getArea()")]),v._v(" "),_("p",[v._v("返回投影平面上多边形的面积")]),v._v(" "),_("p",[v._v("intersectsExtent(extent)")]),v._v(" "),_("p",[v._v("测试几何形状和通过的范围是否相交")]),v._v(" "),_("p",[v._v("rotate(angle, anchor)")]),v._v(" "),_("p",[v._v("围绕给定的坐标旋转几何图形。这将修改现有的几何坐标")]),v._v(" "),_("p",[v._v("scale(sx, opt_sy, opt_anchor)")]),v._v(" "),_("p",[v._v("缩放几何图形(可选原点)。这将修改现有的几何坐标。sx：x方向上的缩放因子；sy：Y轴上的缩放因子；opt_anchor`：缩放原点(默认为几何范围的中心)")]),v._v(" "),_("p",[v._v("translate(deltaX, deltaY)")]),v._v(" "),_("p",[v._v("翻转几何图形。这将修改现有的几何坐标。如果您想要一个新的几何体，那么首先clone()这个几何体")]),v._v(" "),_("p",[v._v("(4)ol.layer.VectorTile()")]),v._v(" "),_("p",[v._v("矢量平铺图层。")]),v._v(" "),_("p",[v._v("图层用于客户端呈现矢量平铺数据。")]),v._v(" "),_("p",[v._v("new ol.layer.Vector({//以下为图层的属性选项， 都可设置，所以皆有getter/setter")]),v._v(" "),_("p",[v._v("opacity:2,//透明度 区间范围为(0, 1) 默认为1")]),v._v(" "),_("p",[v._v("visible:true,//显示属性 布尔值 默认为true")]),v._v(" "),_("p",[v._v("extent:[],//图层渲染的边界范围。该层将不会在此范围之外呈现")]),v._v(" "),_("p",[v._v("zIndex:2,//图层渲染的索引层级。在渲染时，图层将被排序，首先是z-idnex，然后是位置，当为undefined时，对于添加到映射的layers集合中的层，zIndex为0，或者当使用该层的setMap()方法时，zIndex为无穷大")]),v._v(" "),_("p",[v._v("minResolution:3,//该层可见的最小分辨率(包括在内)")]),v._v(" "),_("p",[v._v("maxResolution:6,//该层可见的最大分辨率(包括在内)")]),v._v(" "),_("p",[v._v("renderOrder:,//呈现顺序。函数用于在呈现前对特性进行排序。默认情况下，特性是按照创建它们的顺序绘制的。使用null来避免排序，但是得到一个未定义的绘制顺序")]),v._v(" "),_("p",[v._v("renderBuffer:100,//默认为100 缓冲区")]),v._v(" "),_("p",[v._v("renderMode:'vector',//默认为'vector' 矢量图层的渲染模式")]),v._v(" "),_("p",[v._v("source:new ol.source.VectorSource(),//图层源")]),v._v(" "),_("p",[v._v("map: ,//把图层覆盖在地图上，地图不会在它的图层集合中管理这个图层，这个图层将被呈现在顶部，这对于临时层非常有用")]),v._v(" "),_("p",[v._v("declutter:false,//默认为false 整理图片和文字。清理应用于所有图像和文本样式，优先级由样式的z-index定义。z-index指数越低，优先级越高")]),v._v(" "),_("p",[v._v("style:new ol.style.Style(),//图层样式")]),v._v(" "),_("p",[v._v("updateWhileAnimating:false,//默认为false")]),v._v(" "),_("p",[v._v("updateWhileInteracting:false,//默认为false")]),v._v(" "),_("p",[v._v("preload:,//")]),v._v(" "),_("p",[v._v("renderOrder:,//")]),v._v(" "),_("p",[v._v("useInterimTilesOnError:true,//错误时使用临时贴片 默认true")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("3、视图view")]),v._v(" "),_("p",[v._v("设置视图view由三种状态决定：center中心、resolution分辨率、rotation旋转，每个状态都有相应的getter和setter。")]),v._v(" "),_("p",[v._v("可以在视图里定义地图中心点、层级、分辨率、旋转以及地图投影等。")]),v._v(" "),_("p",[v._v("视图对象受到约束，主要有分辨率约束、旋转约束、中心约束。")]),v._v(" "),_("p",[v._v("分辨率约束切换到特定分辨率时，特定分辨率主要由以下选项决定：resolutions、maxResolution、maxZoom、zoomFactor。如果已经设置resolutions，其他选项就可忽略。")]),v._v(" "),_("p",[v._v("旋转约束会切换到特定的角度。它由以下选项决定:enableRotation和constrainRotation。在默认情况下，当接近水平线时，旋转值会突然变为零。")]),v._v(" "),_("p",[v._v("中心约束由范围选项决定。默认情况下，中心完全不受约束。")]),v._v(" "),_("p",[v._v("(1)视图选项")]),v._v(" "),_("p",[v._v("1)中心点center")]),v._v(" "),_("p",[v._v("视图的初始中心，中心的坐标系由投影projection指定，如果未设置此参数，则不会获取层源，但是之后可以使用#setCenter设置中心。")]),v._v(" "),_("p",[v._v("let center = ol.proj.fromLonLat([longitude, latitude]);//未限制地图范围时")]),v._v(" "),_("p",[v._v("let center = ol.proj.transform([minX, minY, maxX, maxY]，'EPSG:4326', 'EPSG:3857');//限制地图显示范围时设置中心点 X代表经度， Y代表纬度")]),v._v(" "),_("p",[v._v('ol.proj.transform([], "EPSG:", "EPSG:")是经纬度投影转换')]),v._v(" "),_("p",[v._v("获取中心：map.getView().getCenter()")]),v._v(" "),_("p",[v._v("设置中心：map.getView().setCenter(center)")]),v._v(" "),_("p",[v._v("2)投影projection")]),v._v(" "),_("p",[v._v("视图拥有projection投影，投影决定了中心的坐标系，其单位决定了分辨率的单位(每个像素的投影单位)。默认投影为球面墨卡托(EPSG:3857)。")]),v._v(" "),_("p",[v._v("获取投影：map.getView().getProjection()")]),v._v(" "),_("p",[v._v("设置投影：map.getView().setProjection()")]),v._v(" "),_("p",[v._v("3)分辨率resolution")]),v._v(" "),_("p",[v._v("视图的初始分辨率，单位是每像素的投影单位(例如米每像素)。")]),v._v(" "),_("p",[v._v("另一种方法是设置缩放zoom。缩放可以设置：最大层级maxZoom、最小层级minZoom以及当前层级zoom")]),v._v(" "),_("p",[v._v("let view = new ol.View({")]),v._v(" "),_("p",[v._v("// center: center,")]),v._v(" "),_("p",[v._v("zoom: curZoom,")]),v._v(" "),_("p",[v._v("minZoom: minZoom,")]),v._v(" "),_("p",[v._v("maxZoom: maxZoom,")]),v._v(" "),_("p",[v._v("});")]),v._v(" "),_("p",[v._v("获取分辨率：map.getView().getResolution()")]),v._v(" "),_("p",[v._v("获取给定范围(以映射单元为单位)和大小(以像素为单位)的分辨率：map.getView().getResolutionForExtent(extent, opt_size)；")]),v._v(" "),_("p",[v._v("获取缩放级别的分辨率：map.getView().getResolutionForZoom(zoom)；")]),v._v(" "),_("p",[v._v("获取视图最大值分辨率：map.getView().getMaxResolution()；")]),v._v(" "),_("p",[v._v("获取视图最小值分辨率：map.getView().getMinResolution()；")]),v._v(" "),_("p",[v._v("设置分辨率：map.getView().setResolution(resolution)")]),v._v(" "),_("p",[v._v("4)旋转rotation")]),v._v(" "),_("p",[v._v("初始旋转角度为弧度(正顺时针旋转，0表示向北)。")]),v._v(" "),_("p",[v._v("获取旋转调用方法map.getView().getRotation()；")]),v._v(" "),_("p",[v._v("设置旋转调用方法map.getView().setRotation(rotation);")]),v._v(" "),_("p",[v._v("5)缩放zoom")]),v._v(" "),_("p",[v._v("仅在未定义分辨率时使用。")]),v._v(" "),_("p",[v._v("缩放级别用于计算视图的初始分辨率。初始分辨率是使用#constrainResolution方法确定的。")]),v._v(" "),_("p",[v._v("获取缩放层级：map.getView().getZoom()；")]),v._v(" "),_("p",[v._v("获取最大缩放层级：map.getView().getMaxZoom()；")]),v._v(" "),_("p",[v._v("获取最小缩放层级：map.getView().getMinZoom()；")]),v._v(" "),_("p",[v._v("获取缩放层级的分辨率：map.getView().getZoomForResolution(resolution)；")]),v._v(" "),_("p",[v._v("设置缩放层级：map.getView().setZoom(zoom)；")]),v._v(" "),_("p",[v._v("设置最大缩放层级：map.getView().setMaxZoom(zoom)；")]),v._v(" "),_("p",[v._v("设置最小缩放层级：map.getView().setMinZoom(zoom)；")]),v._v(" "),_("p",[v._v("6)旋转约束constrainRotation")]),v._v(" "),_("p",[v._v("旋转约束。false为未约束，true为未约束但是接近于0。数字限制了旋转到该值的数量。")]),v._v(" "),_("p",[v._v("7)启用旋转enableRotation")]),v._v(" "),_("p",[v._v("如果为false，则始终使用将旋转设置为零的旋转约束。如果启用为false，则没有效果。")]),v._v(" "),_("p",[v._v("8)约束范围extent")]),v._v(" "),_("p",[v._v("中心点不能超出这个范围。")]),v._v(" "),_("p",[v._v("(2)视图方法")]),v._v(" "),_("p",[v._v("1)动画animate(var_args)")]),v._v(" "),_("p",[v._v("单个动画")]),v._v(" "),_("p",[v._v("动画视图。视图的中心、缩放(或分辨率)和旋转可以通过动画来实现视图状态之间的平滑转换。")]),v._v(" "),_("p",[v._v("默认情况下，动画持续时间为1秒，并且类型为in-and-out easing。")]),v._v(" "),_("p",[v._v("通过设置持续时间duration(以毫秒为单位)和缓动选项easing(参见模块:ol/easing)来定制此行为。")]),v._v(" "),_("p",[v._v("easing:")]),v._v(" "),_("p",[v._v("easeIn：平缓加速")]),v._v(" "),_("p",[v._v("easeOut：平缓减速")]),v._v(" "),_("p",[v._v("inAndOut：平缓开始，先加速，再减速")]),v._v(" "),_("p",[v._v("linear：匀速")]),v._v(" "),_("p",[v._v("upAndDown：平缓开始，加速，最后再减速。这与模块的一般行为相同:ol/easing~inAndOut，但是最终的减速被延迟了")]),v._v(" "),_("p",[v._v("多个动画")]),v._v(" "),_("p",[v._v("要将多个动画连接在一起，请使用多个动画对象调用该方法。")]),v._v(" "),_("p",[v._v("如果提供一个函数作为animate方法的最后一个参数，它将在动画系列的末尾被调用。")]),v._v(" "),_("p",[v._v("如果动画系列独立完成，回调函数将被调用true;如果动画系列被取消，回调函数将被调用false。")]),v._v(" "),_("p",[v._v("取消动画")]),v._v(" "),_("p",[v._v("动画通过用户交互(例如拖动地图)或调用view.setCenter()、view.setResolution()或view.setRotation()(或调用其中一个方法的另一个方法)来取消。")]),v._v(" "),_("p",[v._v("2)取消动画cancelAnimations()")]),v._v(" "),_("p",[v._v("取消任何正在进行的动画。")]),v._v(" "),_("p",[v._v("(3)getAnimating()")]),v._v(" "),_("p",[v._v("确定视图是否处于动画状态。返回布尔值。")]),v._v(" "),_("p",[v._v("4)计算范围calculateExtent(opt_size)")]),v._v(" "),_("p",[v._v("计算当前视图状态的范围和传递的大小。opt_size指盒子像素尺寸，如未提供，将使用此视图的第一个映射的大小。")]),v._v(" "),_("p",[v._v("尺寸是盒子的像素尺寸，计算的范围应该与之匹配。")]),v._v(" "),_("p",[v._v("想要获取整个底图映射的范围，使用map.getSize()")]),v._v(" "),_("p",[v._v("5)centerOn(coordinate, size, position)")]),v._v(" "),_("p",[v._v("以坐标和视图位置为中心。")]),v._v(" "),_("p",[v._v("coordinate：坐标点")]),v._v(" "),_("p",[v._v("size：盒子像素尺寸")]),v._v(" "),_("p",[v._v("position：视图的居中位置")]),v._v(" "),_("p",[v._v("4、交互动作interaction")]),v._v(" "),_("p",[v._v("通常只用于创建子类，而不在应用程序中实例化。")]),v._v(" "),_("p",[v._v("用于更改映射状态的用户操作。有些类似于控件，但不与DOM元素关联。")]),v._v(" "),_("p",[v._v("虽然交互没有DOM元素，但是它们中的一些会呈现向量，因此在屏幕上是可见的。")]),v._v(" "),_("p",[v._v("添加交互动作使用：map.addInteraction(interaction);")]),v._v(" "),_("p",[v._v("OpenLayers 中可实例化的子类及其功能如下：")]),v._v(" "),_("p",[v._v("可实例化子类")]),v._v(" "),_("p",[v._v("功能")]),v._v(" "),_("p",[v._v("doubleclickzoom interaction")]),v._v(" "),_("p",[v._v("双击放大交互功能")]),v._v(" "),_("p",[v._v("draganddrop")]),v._v(" "),_("p",[v._v("以“拖文件到地图中”的交互添加图层")]),v._v(" "),_("p",[v._v("dragbox")]),v._v(" "),_("p",[v._v("拉框，用于划定一个矩形范围，常用于放大地图")]),v._v(" "),_("p",[v._v("dragpan")]),v._v(" "),_("p",[v._v("拖拽平移地图")]),v._v(" "),_("p",[v._v("dragrotateandzoom")]),v._v(" "),_("p",[v._v("拖拽方式进行缩放和旋转地图")]),v._v(" "),_("p",[v._v("dragrotate")]),v._v(" "),_("p",[v._v("拖拽方式旋转地图")]),v._v(" "),_("p",[v._v("dragzoom")]),v._v(" "),_("p",[v._v("拖拽方式缩放地图")]),v._v(" "),_("p",[v._v("draw")]),v._v(" "),_("p",[v._v("绘制地理要素功能")]),v._v(" "),_("p",[v._v("interaction defaults")]),v._v(" "),_("p",[v._v("默认添加的交互功能")]),v._v(" "),_("p",[v._v("keyboardpan")]),v._v(" "),_("p",[v._v("键盘方式平移地图")]),v._v(" "),_("p",[v._v("keyboardzoom")]),v._v(" "),_("p",[v._v("键盘方式缩放地图")]),v._v(" "),_("p",[v._v("select")]),v._v(" "),_("p",[v._v("选择要素功能")]),v._v(" "),_("p",[v._v("modify")]),v._v(" "),_("p",[v._v("更改要素")]),v._v(" "),_("p",[v._v("mousewheelzoom")]),v._v(" "),_("p",[v._v("鼠标滚轮缩放功能")]),v._v(" "),_("p",[v._v("pinchrotate")]),v._v(" "),_("p",[v._v("手指旋转地图，针对触摸屏")]),v._v(" "),_("p",[v._v("pinchzoom")]),v._v(" "),_("p",[v._v("手指进行缩放，针对触摸屏")]),v._v(" "),_("p",[v._v("pointer")]),v._v(" "),_("p",[v._v("鼠标的用户自定义事件基类")]),v._v(" "),_("p",[v._v("snap")]),v._v(" "),_("p",[v._v("鼠标捕捉，当鼠标距离某个要素一定距离之内，自动吸附到要素")]),v._v(" "),_("p",[v._v("(1)默认交互功能ol.interaction.defaylts()")]),v._v(" "),_("p",[v._v("主要是最为常用的功能，如缩放、平移和旋转地图等，具体功能有如下这些：")]),v._v(" "),_("p",[v._v("默认交互")]),v._v(" "),_("p",[v._v("功能")]),v._v(" "),_("p",[v._v("ol.interaction.DragRotate")]),v._v(" "),_("p",[v._v("鼠标拖拽旋转，一般配合一个键盘按键辅助")]),v._v(" "),_("p",[v._v("ol.interaction.DragZoom")]),v._v(" "),_("p",[v._v("鼠标拖拽缩放，一般配合一个键盘按键辅助")]),v._v(" "),_("p",[v._v("ol.interaction.DoubleClickZoom")]),v._v(" "),_("p",[v._v("鼠标或手指双击缩放地图")]),v._v(" "),_("p",[v._v("ol.interaction.PinchRotate")]),v._v(" "),_("p",[v._v("两个手指旋转地图，针对触摸屏")]),v._v(" "),_("p",[v._v("ol.interaction.PinchZoom")]),v._v(" "),_("p",[v._v("两个手指缩放地图，针对触摸屏")]),v._v(" "),_("p",[v._v("ol.interaction.DragPan")]),v._v(" "),_("p",[v._v("鼠标或手指拖拽平移地图")]),v._v(" "),_("p",[v._v("ol.interaction.KeyboardZoom")]),v._v(" "),_("p",[v._v("使用键盘 + 和 - 按键进行缩放")]),v._v(" "),_("p",[v._v("ol.interaction.KeyboardPan")]),v._v(" "),_("p",[v._v("使用键盘方向键平移地图")]),v._v(" "),_("p",[v._v("ol.interaction.MouseWheelZoom")]),v._v(" "),_("p",[v._v("鼠标滚轮缩放地图")]),v._v(" "),_("p",[v._v("(2)针对矢量图层元素的交互功能")]),v._v(" "),_("p",[v._v("1)选择ol.interaction.Select()")]),v._v(" "),_("p",[v._v("选择矢量元素的交互功能。")]),v._v(" "),_("p",[v._v("默认情况下，所选矢量元素的样式不相同，因此这种交互可以用于可视化高亮显示，以及为其他操作(如修改或输出)选择特性。")]),v._v(" "),_("p",[v._v("选定的矢量元素将被添加到内部非托管图层。")]),v._v(" "),_("p",[v._v("有三种方式控制矢量元素的选择：")]),v._v(" "),_("p",[v._v("使用由condition定义的浏览器事件和toggle切换的add/remove以及multi选项")]),v._v(" "),_("p",[v._v("一个layer过滤器")]),v._v(" "),_("p",[v._v("一个使用filter选项的进一步矢量元素过滤器")]),v._v(" "),_("p",[v._v("2)绘制ol.interaction.Draw()")]),v._v(" "),_("p",[v._v("用于绘制特征几何图形的交互功能。")]),v._v(" "),_("p",[v._v("绘制交互允许绘制几何地理要素，可选一个参数为对象，可包含参数如下：")]),v._v(" "),_("p",[v._v("features：绘制的要素的目标集合；")]),v._v(" "),_("p",[v._v("source：绘制的要素的目标图层源；")]),v._v(" "),_("p",[v._v("snapTolerance：自动吸附完成点的像素距离，也就是说当鼠标位置距离闭合点小于该值设置的时候，会自动吸附到闭合点，默认值是 12；")]),v._v(" "),_("p",[v._v("type：绘制的地理要素类型，ol.geom.GeometryType类型，包含 Point、 LineString、 Polygon、MultiPoint、MultiLineString 或者 MultiPolygon；")]),v._v(" "),_("p",[v._v("minPointsPerRing：绘制一个多边形需要的点数最小值，数值类型，默认是 3；")]),v._v(" "),_("p",[v._v("style：要素素描的样式；")]),v._v(" "),_("p",[v._v("geometryName：绘制的地理要素的名称，string类型")]),v._v(" "),_("p",[v._v("3)修改ol.interaction.Modify()")]),v._v(" "),_("p",[v._v("用于修改矢量元素几何图形的交互功能。")]),v._v(" "),_("p",[v._v("若想修改已添加到存在的矢量源中的矢量元素，需要使用modify选项构建修改交互动作。")]),v._v(" "),_("p",[v._v("如若想修改集合中的矢量元素(比如用选择交互的集合)，需要使用features选项构建交互。该交互必须使用source或者features构建。")]),v._v(" "),_("p",[v._v("默认情况下，当按下alt键时，交互允许删除顶点。想要使用不同的删除条件配置交互，请使用deleteCondition选项。")]),v._v(" "),_("p",[v._v("5、控件Control")]),v._v(" "),_("p",[v._v("控件是一个可见的小部件，其DOM元素位于屏幕上的固定位置。它们可以包含用户输入(按钮)，或者只是提供信息;位置是使用CSS确定的。这是一个虚基类，不负责实例化特定的控件。")]),v._v(" "),_("p",[v._v("默认情况下，这些元素被放置在具有CSS类名称ol-overlaycontainer-stopevent的容器中，但是可以使用任何外部DOM元素。")]),v._v(" "),_("p",[v._v("let myControl = new ol.control.Control({//定义一个控件")]),v._v(" "),_("p",[v._v("element:myElement")]),v._v(" "),_("p",[v._v("})")]),v._v(" "),_("p",[v._v("//然后添加到地图上")]),v._v(" "),_("p",[v._v("map.addControl(myControl);")]),v._v(" "),_("p",[v._v("主要的属性选项有：")]),v._v(" "),_("p",[v._v("element：DOM元素，元素是控件的容器元素。只有在开发自定义控件时才需要指定这一点")]),v._v(" "),_("p",[v._v("render：重新呈现控件时调用的函数。这在requestAnimationFrame回调中调用")]),v._v(" "),_("p",[v._v("target：DOM元素，想要控件在映射的视图端口之外呈现，需要指定目标对象")]),v._v(" "),_("p",[v._v("其中包含的控件有：")]),v._v(" "),_("p",[v._v("控件")]),v._v(" "),_("p",[v._v("功能")]),v._v(" "),_("p",[v._v("controldefaults")]),v._v(" "),_("p",[v._v("地图默认包含的控件，包含缩放控件和旋转控件")]),v._v(" "),_("p",[v._v("fullscreencontrol")]),v._v(" "),_("p",[v._v("全屏控件，用于全屏幕查看地图")]),v._v(" "),_("p",[v._v("mousepositioncontrol")]),v._v(" "),_("p",[v._v("鼠标位置控件，显示鼠标所在地图位置的坐标，可以自定义投影")]),v._v(" "),_("p",[v._v("overviewmapcontrol")]),v._v(" "),_("p",[v._v("地图全局视图控件")]),v._v(" "),_("p",[v._v("rotatecontrol")]),v._v(" "),_("p",[v._v("地图旋转控件")]),v._v(" "),_("p",[v._v("scalelinecontrol")]),v._v(" "),_("p",[v._v("比例尺控件")]),v._v(" "),_("p",[v._v("zoomcontrol")]),v._v(" "),_("p",[v._v("缩放控件")]),v._v(" "),_("p",[v._v("zoomslidercontrol")]),v._v(" "),_("p",[v._v("缩放刻度控件")]),v._v(" "),_("p",[v._v("zoomtoextentcontrol")]),v._v(" "),_("p",[v._v("缩放到全局控件")]),v._v(" "),_("p",[v._v("6、叠加层Overlay")]),v._v(" "),_("p",[v._v("要显示在地图上方并附加到单个地图位置的元素。与控件不同的是，它们不在屏幕上的固定位置，而是绑定到地理坐标上，因此平移地图将移动 overlay ，而不是控件。")]),v._v(" "),_("p",[v._v("let popup = new ol.Overlay({")]),v._v(" "),_("p",[v._v("element:document.getElementById('popup'),")]),v._v(" "),_("p",[v._v("...")]),v._v(" "),_("p",[v._v("});")]),v._v(" "),_("p",[v._v("popup.setPosition(coordinate);")]),v._v(" "),_("p",[v._v("map.addOverlay(popup);")]),v._v(" "),_("p",[v._v("Overlay选项")]),v._v(" "),_("p",[v._v("(1)id")]),v._v(" "),_("p",[v._v("设置 overlay的 id，字符串类型。")]),v._v(" "),_("p",[v._v("获取id：map.getOverlayById(id)或者overlay.getId()")]),v._v(" "),_("p",[v._v("(2)element")]),v._v(" "),_("p",[v._v("overlay 元素，DOM元素")]),v._v(" "),_("p",[v._v("获取：overlay.getElement()")]),v._v(" "),_("p",[v._v("设置：overlay.setElement(element)")]),v._v(" "),_("p",[v._v("(3)offset")]),v._v(" "),_("p",[v._v("偏移量(以像素为单位)，用于定位 overlay ，数组类型，默认为[0, 0]：")]),v._v(" "),_("p",[v._v("数组第一个元素为水平偏移，正右负左；")]),v._v(" "),_("p",[v._v("数组第二个元素为垂直，正下负上；")]),v._v(" "),_("p",[v._v("获取偏移值：overlay.getOffset()")]),v._v(" "),_("p",[v._v("设置偏移值：overlay.setOffset(offset)")]),v._v(" "),_("p",[v._v("(4)position")]),v._v(" "),_("p",[v._v("地图投影中的位置。")]),v._v(" "),_("p",[v._v("获取：overlay.getPosition()")]),v._v(" "),_("p",[v._v("设置：overlay.setPosition(position)，如果位置未定义undefined，则覆盖被隐藏。")]),v._v(" "),_("p",[v._v("(5)positioning")]),v._v(" "),_("p",[v._v("定义 overlay 相对于其位置属性的实际位置，默认为top-left，还有'bottom-left', 'bottom-center', 'bottom-right', 'center-left', 'center-center', 'center-right', 'top-left','top-center', and 'top-right'.")]),v._v(" "),_("p",[v._v("获取：overlay.getPositioning()")]),v._v(" "),_("p",[v._v("设置：overlay.setPositioning(positioning)")]),v._v(" "),_("p",[v._v("(6)autoPan")]),v._v(" "),_("p",[v._v("默认为false，如果设置为true，则在调用setPosition将平移映射，以便在当前视图中 overlay 完全可见。")]),v._v(" "),_("p",[v._v("(7)autoPanAnimation")]),v._v(" "),_("p",[v._v("动画选项用于平移 overlay 到视图中。此动画仅在启用autoPan时使用。可以提供一个持续时间和缓动来定制动画。")]),v._v(" "),_("p",[v._v("(8)stopEvent")]),v._v(" "),_("p",[v._v("默认为true，是否应该停止到map视图端口的事件传播。")]),v._v(" "),_("p",[v._v("如果为true，则将 overlay 放置在与控件相同的容器中(CSS class nameol-overlaycontainer-stopevent)")]),v._v(" "),_("p",[v._v("如果为false，它用className属性指定的CSS类名放置在容器中。")]),v._v(" "),_("p",[v._v("(9)className")]),v._v(" "),_("p",[v._v("CSS class name.")]),v._v(" "),_("p",[v._v("(10)autoPanMargin")]),v._v(" "),_("p",[v._v("地图自动平移时，地图边缘与 overlay 的留白(空隙)，单位是像素，默认是 20像素")]),v._v(" "),_("p",[v._v("7、投影Projections")]),v._v(" "),_("p",[v._v("需要给所有坐标和范围提供视图投影系(默认是EPAG:3857)。")]),v._v(" "),_("p",[v._v("转换投影系，使用ol.proj.transform()和ol.proj.transformExtendt进行转换")]),v._v(" "),_("p",[v._v("(1)、ol.proj")]),v._v(" "),_("p",[v._v("1)ol.proj.addCoordinateTransforms(source, destination, forward, inverse)")]),v._v(" "),_("p",[v._v("注册坐标转换函数来转换源投影和目标投影之间的坐标。正、反函数转换坐标对;此函数将这些转换为内部使用的处理区段和坐标数组的函数")]),v._v(" "),_("p",[v._v("source：源投影")]),v._v(" "),_("p",[v._v("destination：目标投影")]),v._v(" "),_("p",[v._v("forward：接受ol的正向变换函数(即从源投影到目标投影)。作为参数，并返回转换后的ol.Coordinate")]),v._v(" "),_("p",[v._v("inverse：接受ol的逆变换函数(即从目标投影到源投影)。作为参数，并返回转换后的ol.Coordinate")]),v._v(" "),_("p",[v._v("2)ol.proj.addEquivalentProjections(projections)")]),v._v(" "),_("p",[v._v("注册不改变坐标的转换函数。它们允许在具有相同含义的投影之间进行转换。")]),v._v(" "),_("p",[v._v("3)ol.proj.addProjection(projection)")]),v._v(" "),_("p",[v._v("将投影对象添加到受支持的投影列表中，这些投影可以通过它们的SRS码进行查找。")]),v._v(" "),_("p",[v._v("4)ol.proj.equivalent(projection1, projection2)")]),v._v(" "),_("p",[v._v("检查两个投影是否相同，即一个投影中的每个坐标确实表示另一个投影中的相同地理点。")]),v._v(" "),_("p",[v._v("5)ol.proj.fromLonLat(coordinate, opt_projection)")]),v._v(" "),_("p",[v._v("将经纬度坐标转换为不同的投影")]),v._v(" "),_("p",[v._v("coordinate：经纬度数组，经度在前，纬度在后")]),v._v(" "),_("p",[v._v("projection：目标投影。默认是Web Mercator，即“EPSG: 3857”")]),v._v(" "),_("p",[v._v("6)ol.proj.get(projectionLike)")]),v._v(" "),_("p",[v._v("获取指定代码的投影对象。")]),v._v(" "),_("p",[v._v("7)ol.proj.getTransform(source, destination)")]),v._v(" "),_("p",[v._v("给定类似于投影的对象，搜索转换函数将坐标数组从源投影转换为目标投影。")]),v._v(" "),_("p",[v._v("8)ol.proj.setProj4(proj4)")]),v._v(" "),_("p",[v._v("proj4注册。如果没有显式注册，则假定proj4js将加载在全局名称空间中")]),v._v(" "),_("p",[v._v("ol.proj.setProj4(proj4);")]),v._v(" "),_("p",[v._v("9)ol.proj.toLonLat(coordinate, opt_projection)")]),v._v(" "),_("p",[v._v("将坐标转换为经度/纬度")]),v._v(" "),_("p",[v._v("coordinate：投影坐标")]),v._v(" "),_("p",[v._v("projection：坐标的投影，默认是Web Mercator，即“EPSG: 3857”")]),v._v(" "),_("p",[v._v("10)ol.proj.transform(coordinate, source, destination)")]),v._v(" "),_("p",[v._v("将坐标从源投影转换为目标投影，这将返回一个新的坐标(并且不修改原始坐标)。")]),v._v(" "),_("p",[v._v("coordinate：坐标")]),v._v(" "),_("p",[v._v("source：源投影")]),v._v(" "),_("p",[v._v("destination：目标投影")]),v._v(" "),_("p",[v._v("11)ol.proj.transformExtent")]),v._v(" "),_("p",[v._v("将范围从源投影转换为目标投影，这将返回一个新范围(并且不修改原始范围)。")]),v._v(" "),_("p",[v._v("12)ol.proj.Units{string}")]),v._v(" "),_("p",[v._v("投影单位：'degrees', 'ft', 'm', 'pixels', 'tile-pixels' or 'us-ft'\n————————————————\n版权声明：本文为CSDN博主「weixin_39594080」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_39594080/article/details/111518979")])])}),[],!1,null,null,null);_.default=o.exports}}]);